list_nav <- data.frame(x = rep(c(1:nrow(new_birds)), lengths(new_birds$songs)), y = unlist(sapply(1:length(lengths(new_birds$songs)), function(x){c(1:(lengths(new_birds$songs)[x]))})))
#subset list_nav using innov_bools
to_innov <- list_nav[which(innov_bools), ]
#for each song to be innovated
for(j in 1:nrow(to_innov)){
#store sequence to edit
sequence <- new_birds$songs[[to_innov$x[j]]][to_innov$y[j]]
sequence <- strsplit(sequence, "")[[1]]
#generate 1000 edits and calculate entropies
edits <- lapply(1:1000, function(x){edit(states, sequence)})
entropies <- sapply(1:length(edits), function(x){entropy(edits[[x]])})
#sample edits, weighted by entropies, and overwrite previous sequence
new_birds$songs[[to_innov$x[j]]][to_innov$y[j]] <- paste0(sample(edits, 1, prob = entropies^pref_strength)[[1]], collapse = "")
}
#add new_birds to birds
birds <- data.table::rbindlist(list(birds, new_birds))
#mortality
birds <- birds[-sample(1:nrow(birds), babies), ]
#store entropy of current songs in output
output[[i]] <- sapply(1:length(unlist(birds$songs)), function(x){entropy(strsplit(unlist(birds$songs)[x], "")[[1]])})
}
#print mean entropy over time
sapply(1:length(output), function(x){mean(output[[x]])})
#colors for plotting after each timepoint
colors <- rainbow(t*1.25) #times 1.2 so it doesn't loop back around
#parameters for plotting
bw <- 0.05
buffer <- 0.05
ymax <- 8
for(i in 1:length(output)){
if(i == 1){
par(mar = c(4, 4, 1, 1))
plot(density(output[[i]], bw = bw), xlab = "Entropy", main = "", xlim = c(min(unlist(output))-(min(unlist(output))*buffer), max(unlist(output))+(max(unlist(output))*buffer)), ylim = c(0, ymax))
}
if(i > 1){lines(density(output[[i]], bw = bw)$x, density(output[[i]], bw = bw)$y, type = "l", col = colors[i-1])}
}
# DEFINE FUNCTIONS --------------------------------------------------------
#basic shannon entropy measurement (trimmed from acss)
entropy <- function(chain){
y <- as.numeric(table(chain))/length(chain)
return(-sum(y*log2(y)))
}
#edit function (without recombination or invention)
edit <- function(states, sequence){
#create copy of sequence to modify
new_sequence <- sequence
#determine change will be addition, deletion, or substitution
change <- sample(3, 1)
if(change == 1){
#addition
y <- sample((length(new_sequence) + 1), 1) #the position where the new state will appear
if(y == 1){new_sequence <- c(sample(states, 1), new_sequence)}
if(y == (length(new_sequence) + 1)){new_sequence <- c(new_sequence, sample(states, 1))}
if(y %in% c(2:length(new_sequence))){new_sequence <- c(new_sequence[1:(y - 1)], sample(states, 1), new_sequence[y:length(new_sequence)])}
}
if(change == 2){
#deletion
new_sequence <- new_sequence[-sample(length(new_sequence), 1)]
}
if(change == 3){
#substitution
old <- sample(length(new_sequence), 1) #store old state so we can exclude it from sampling below
new_sequence[sample(length(new_sequence), 1)] <- sample(states[-which(states %in% new_sequence[old])], 1)
}
return(new_sequence)
}
# INITIALIZE OBJECTS AND PARAMETERS ---------------------------------------
#set states
states <- c("A", "B", "C", "D", "E")
#set number of songs
n_songs <- 20
#mean and sd of song length
m_length <- 10
sd_length <- 3
#mean and sd of song rep size
m_rep <- 4
sd_rep <- 2
#set number of timesteps
t <- 100
#set number of birds
n_birds <- 50
#set number of demonstrators
dems <- 3
#set turnover rate
turnover <- 0.2
#set innovation rate
mu <- 0.5
#set preference for higher entropy edits
pref_strength <- 500
# RUN SIMULATION ----------------------------------------------------------
#generate initial songs
songs <- sapply(1:n_songs, function(x){paste0(sample(states, ceiling(rnorm(1, m_length, sd_length)), replace = TRUE), collapse = "")})
#initialize population of birds
birds <- data.table::data.table(songs = lapply(1:n_birds, function(x){sample(songs, ceiling(truncnorm::rtruncnorm(1, a = 0, b = n_songs - 1, mean = m_rep, sd = sd_rep)))}))
#create output vector
output <- list()
for(i in 1:t){
#get number of new birds who will learn
babies <- n_birds*turnover
#get population of new birds, sampling songs from existing birds
new_birds <- data.table::data.table(songs = lapply(1:babies, function(x){
to_learn <- as.data.frame(table(unlist(birds$songs[sample(nrow(birds), dems)])))
as.character(sample(to_learn$Var1, ceiling(truncnorm::rtruncnorm(1, a = 1, b = nrow(to_learn) - 1, mean = m_rep, sd = sd_rep)), prob = to_learn$Freq))
}))
#boolean vector of songs
innov_bools <- sapply(1:sum(lengths(new_birds$songs)), function(x){sample(c(TRUE, FALSE), 1, prob = c(mu, 1 - mu))})
#create data frame to navigate list of lists
list_nav <- data.frame(x = rep(c(1:nrow(new_birds)), lengths(new_birds$songs)), y = unlist(sapply(1:length(lengths(new_birds$songs)), function(x){c(1:(lengths(new_birds$songs)[x]))})))
#subset list_nav using innov_bools
to_innov <- list_nav[which(innov_bools), ]
#for each song to be innovated
for(j in 1:nrow(to_innov)){
#store sequence to edit
sequence <- new_birds$songs[[to_innov$x[j]]][to_innov$y[j]]
sequence <- strsplit(sequence, "")[[1]]
#generate 1000 edits and calculate entropies
edits <- lapply(1:1000, function(x){edit(states, sequence)})
entropies <- sapply(1:length(edits), function(x){entropy(edits[[x]])})
#sample edits, weighted by entropies, and overwrite previous sequence
new_birds$songs[[to_innov$x[j]]][to_innov$y[j]] <- paste0(sample(edits, 1, prob = entropies^pref_strength)[[1]], collapse = "")
}
#add new_birds to birds
birds <- data.table::rbindlist(list(birds, new_birds))
#mortality
birds <- birds[-sample(1:nrow(birds), babies), ]
#store entropy of current songs in output
output[[i]] <- sapply(1:length(unlist(birds$songs)), function(x){entropy(strsplit(unlist(birds$songs)[x], "")[[1]])})
}
#print mean entropy over time
sapply(1:length(output), function(x){mean(output[[x]])})
#colors for plotting after each timepoint
colors <- rainbow(t*1.25) #times 1.2 so it doesn't loop back around
#parameters for plotting
bw <- 0.05
buffer <- 0.05
ymax <- 8
for(i in 1:length(output)){
if(i == 1){
par(mar = c(4, 4, 1, 1))
plot(density(output[[i]], bw = bw), xlab = "Entropy", main = "", xlim = c(min(unlist(output))-(min(unlist(output))*buffer), max(unlist(output))+(max(unlist(output))*buffer)), ylim = c(0, ymax))
}
if(i > 1){lines(density(output[[i]], bw = bw)$x, density(output[[i]], bw = bw)$y, type = "l", col = colors[i-1])}
}
output[[t]]
birds
# DEFINE FUNCTIONS --------------------------------------------------------
#basic shannon entropy measurement (trimmed from acss)
entropy <- function(chain){
y <- as.numeric(table(chain))/length(chain)
return(-sum(y*log2(y)))
}
#edit function (without recombination or invention)
edit <- function(states, sequence){
#create copy of sequence to modify
new_sequence <- sequence
#determine change will be addition, deletion, or substitution
change <- sample(3, 1)
if(change == 1){
#addition
y <- sample((length(new_sequence) + 1), 1) #the position where the new state will appear
if(y == 1){new_sequence <- c(sample(states, 1), new_sequence)}
if(y == (length(new_sequence) + 1)){new_sequence <- c(new_sequence, sample(states, 1))}
if(y %in% c(2:length(new_sequence))){new_sequence <- c(new_sequence[1:(y - 1)], sample(states, 1), new_sequence[y:length(new_sequence)])}
}
if(change == 2){
#deletion
new_sequence <- new_sequence[-sample(length(new_sequence), 1)]
}
if(change == 3){
#substitution
old <- sample(length(new_sequence), 1) #store old state so we can exclude it from sampling below
new_sequence[sample(length(new_sequence), 1)] <- sample(states[-which(states %in% new_sequence[old])], 1)
}
return(new_sequence)
}
# INITIALIZE OBJECTS AND PARAMETERS ---------------------------------------
#set states
states <- c("A", "B", "C", "D", "E")
#set number of songs
n_songs <- 20
#mean and sd of song length
m_length <- 10
sd_length <- 3
#mean and sd of song rep size
m_rep <- 4
sd_rep <- 2
#set number of timesteps
t <- 100
#set number of birds
n_birds <- 50
#set number of demonstrators
dems <- 3
#set turnover rate
turnover <- 0.2
#set innovation rate
mu <- 0.5
#set preference for higher entropy edits
pref_strength <- 100
# RUN SIMULATION ----------------------------------------------------------
#generate initial songs
songs <- sapply(1:n_songs, function(x){paste0(sample(states, ceiling(rnorm(1, m_length, sd_length)), replace = TRUE), collapse = "")})
#initialize population of birds
birds <- data.table::data.table(songs = lapply(1:n_birds, function(x){sample(songs, ceiling(truncnorm::rtruncnorm(1, a = 0, b = n_songs - 1, mean = m_rep, sd = sd_rep)))}))
#create output vector
output <- list()
for(i in 1:t){
#get number of new birds who will learn
babies <- n_birds*turnover
#get population of new birds, sampling songs from existing birds
new_birds <- data.table::data.table(songs = lapply(1:babies, function(x){
to_learn <- as.data.frame(table(unlist(birds$songs[sample(nrow(birds), dems)])))
as.character(sample(to_learn$Var1, ceiling(truncnorm::rtruncnorm(1, a = 1, b = nrow(to_learn) - 1, mean = m_rep, sd = sd_rep)), prob = to_learn$Freq))
}))
#boolean vector of songs
innov_bools <- sapply(1:sum(lengths(new_birds$songs)), function(x){sample(c(TRUE, FALSE), 1, prob = c(mu, 1 - mu))})
#create data frame to navigate list of lists
list_nav <- data.frame(x = rep(c(1:nrow(new_birds)), lengths(new_birds$songs)), y = unlist(sapply(1:length(lengths(new_birds$songs)), function(x){c(1:(lengths(new_birds$songs)[x]))})))
#subset list_nav using innov_bools
to_innov <- list_nav[which(innov_bools), ]
#for each song to be innovated
for(j in 1:nrow(to_innov)){
#store sequence to edit
sequence <- new_birds$songs[[to_innov$x[j]]][to_innov$y[j]]
sequence <- strsplit(sequence, "")[[1]]
#generate 100 edits and calculate entropies
edits <- lapply(1:100, function(x){edit(states, sequence)})
entropies <- sapply(1:length(edits), function(x){entropy(edits[[x]])})
#sample edits, weighted by entropies, and overwrite previous sequence
new_birds$songs[[to_innov$x[j]]][to_innov$y[j]] <- paste0(sample(edits, 1, prob = entropies^pref_strength)[[1]], collapse = "")
}
#add new_birds to birds
birds <- data.table::rbindlist(list(birds, new_birds))
#mortality
birds <- birds[-sample(1:nrow(birds), babies), ]
#store entropy of current songs in output
output[[i]] <- sapply(1:length(unlist(birds$songs)), function(x){entropy(strsplit(unlist(birds$songs)[x], "")[[1]])})
}
#print mean entropy over time
sapply(1:length(output), function(x){mean(output[[x]])})
#colors for plotting after each timepoint
colors <- rainbow(t*1.25) #times 1.2 so it doesn't loop back around
#parameters for plotting
bw <- 0.05
buffer <- 0.05
ymax <- 8
for(i in 1:length(output)){
if(i == 1){
par(mar = c(4, 4, 1, 1))
plot(density(output[[i]], bw = bw), xlab = "Entropy", main = "", xlim = c(min(unlist(output))-(min(unlist(output))*buffer), max(unlist(output))+(max(unlist(output))*buffer)), ylim = c(0, ymax))
}
if(i > 1){lines(density(output[[i]], bw = bw)$x, density(output[[i]], bw = bw)$y, type = "l", col = colors[i-1])}
}
# DEFINE FUNCTIONS --------------------------------------------------------
#basic shannon entropy measurement (trimmed from acss)
entropy <- function(chain){
y <- as.numeric(table(chain))/length(chain)
return(-sum(y*log2(y)))
}
#edit function (without recombination or invention)
edit <- function(states, sequence){
#create copy of sequence to modify
new_sequence <- sequence
#determine change will be addition, deletion, or substitution
change <- sample(3, 1)
if(change == 1){
#addition
y <- sample((length(new_sequence) + 1), 1) #the position where the new state will appear
if(y == 1){new_sequence <- c(sample(states, 1), new_sequence)}
if(y == (length(new_sequence) + 1)){new_sequence <- c(new_sequence, sample(states, 1))}
if(y %in% c(2:length(new_sequence))){new_sequence <- c(new_sequence[1:(y - 1)], sample(states, 1), new_sequence[y:length(new_sequence)])}
}
if(change == 2){
#deletion
new_sequence <- new_sequence[-sample(length(new_sequence), 1)]
}
if(change == 3){
#substitution
old <- sample(length(new_sequence), 1) #store old state so we can exclude it from sampling below
new_sequence[sample(length(new_sequence), 1)] <- sample(states[-which(states %in% new_sequence[old])], 1)
}
return(new_sequence)
}
# INITIALIZE OBJECTS AND PARAMETERS ---------------------------------------
#set states
states <- c("A", "B", "C", "D", "E")
#set number of songs
n_songs <- 20
#mean and sd of song length
m_length <- 10
sd_length <- 3
#mean and sd of song rep size
m_rep <- 4
sd_rep <- 2
#set number of timesteps
t <- 100
#set number of birds
n_birds <- 50
#set number of demonstrators
dems <- 3
#set turnover rate
turnover <- 0.2
#set innovation rate
mu <- 0.5
#set preference for higher entropy edits
pref_strength <- 100
# RUN SIMULATION ----------------------------------------------------------
#generate initial songs
songs <- sapply(1:n_songs, function(x){paste0(sample(states, ceiling(rnorm(1, m_length, sd_length)), replace = TRUE), collapse = "")})
#initialize population of birds
birds <- data.table::data.table(songs = lapply(1:n_birds, function(x){sample(songs, ceiling(truncnorm::rtruncnorm(1, a = 0, b = n_songs - 1, mean = m_rep, sd = sd_rep)))}))
#create output vector
output <- list()
for(i in 1:t){
#get number of new birds who will learn
babies <- n_birds*turnover
#get population of new birds, sampling songs from existing birds
new_birds <- data.table::data.table(songs = lapply(1:babies, function(x){
to_learn <- as.data.frame(table(unlist(birds$songs[sample(nrow(birds), dems)])))
as.character(sample(to_learn$Var1, ceiling(truncnorm::rtruncnorm(1, a = 1, b = nrow(to_learn) - 1, mean = m_rep, sd = sd_rep)), prob = to_learn$Freq))
}))
#boolean vector of songs
innov_bools <- sapply(1:sum(lengths(new_birds$songs)), function(x){sample(c(TRUE, FALSE), 1, prob = c(mu, 1 - mu))})
#create data frame to navigate list of lists
list_nav <- data.frame(x = rep(c(1:nrow(new_birds)), lengths(new_birds$songs)), y = unlist(sapply(1:length(lengths(new_birds$songs)), function(x){c(1:(lengths(new_birds$songs)[x]))})))
#subset list_nav using innov_bools
to_innov <- list_nav[which(innov_bools), ]
#for each song to be innovated
for(j in 1:nrow(to_innov)){
#store sequence to edit
sequence <- new_birds$songs[[to_innov$x[j]]][to_innov$y[j]]
sequence <- strsplit(sequence, "")[[1]]
#generate 100 edits and calculate entropies
edits <- lapply(1:100, function(x){edit(states, sequence)})
entropies <- sapply(1:length(edits), function(x){entropy(edits[[x]])})
#sample edits, weighted by entropies, and overwrite previous sequence
new_birds$songs[[to_innov$x[j]]][to_innov$y[j]] <- paste0(sample(edits, 1, prob = entropies^pref_strength)[[1]], collapse = "")
}
#add new_birds to birds
birds <- data.table::rbindlist(list(birds, new_birds))
#mortality
birds <- birds[-sample(1:nrow(birds), babies), ]
#store entropy of current songs in output
output[[i]] <- sapply(1:length(unlist(birds$songs)), function(x){entropy(strsplit(unlist(birds$songs)[x], "")[[1]])})
}
#print mean entropy over time
sapply(1:length(output), function(x){mean(output[[x]])})
#colors for plotting after each timepoint
colors <- rainbow(t*1.25) #times 1.2 so it doesn't loop back around
#parameters for plotting
bw <- 0.05
buffer <- 0.05
ymax <- 8
for(i in 1:length(output)){
if(i == 1){
par(mar = c(4, 4, 1, 1))
plot(density(output[[i]], bw = bw), xlab = "Entropy", main = "", xlim = c(min(unlist(output))-(min(unlist(output))*buffer), max(unlist(output))+(max(unlist(output))*buffer)), ylim = c(0, ymax))
}
if(i > 1){lines(density(output[[i]], bw = bw)$x, density(output[[i]], bw = bw)$y, type = "l", col = colors[i-1])}
}
# DEFINE FUNCTIONS --------------------------------------------------------
#basic shannon entropy measurement (trimmed from acss)
entropy <- function(chain){
y <- as.numeric(table(chain))/length(chain)
return(-sum(y*log2(y)))
}
#edit function (without recombination or invention)
edit <- function(states, sequence){
#create copy of sequence to modify
new_sequence <- sequence
#determine change will be addition, deletion, or substitution
change <- sample(3, 1)
if(change == 1){
#addition
y <- sample((length(new_sequence) + 1), 1) #the position where the new state will appear
if(y == 1){new_sequence <- c(sample(states, 1), new_sequence)}
if(y == (length(new_sequence) + 1)){new_sequence <- c(new_sequence, sample(states, 1))}
if(y %in% c(2:length(new_sequence))){new_sequence <- c(new_sequence[1:(y - 1)], sample(states, 1), new_sequence[y:length(new_sequence)])}
}
if(change == 2){
#deletion
new_sequence <- new_sequence[-sample(length(new_sequence), 1)]
}
if(change == 3){
#substitution
old <- sample(length(new_sequence), 1) #store old state so we can exclude it from sampling below
new_sequence[sample(length(new_sequence), 1)] <- sample(states[-which(states %in% new_sequence[old])], 1)
}
return(new_sequence)
}
# INITIALIZE OBJECTS AND PARAMETERS ---------------------------------------
#set states
states <- c("A", "B", "C", "D", "E")
#set number of songs
n_songs <- 40
#mean and sd of song length
m_length <- 20
sd_length <- 3
#mean and sd of song rep size
m_rep <- 8
sd_rep <- 2
#set number of timesteps
t <- 100
#set number of birds
n_birds <- 50
#set number of demonstrators
dems <- 3
#set turnover rate
turnover <- 0.2
#set innovation rate
mu <- 0.5
#set preference for higher entropy edits
pref_strength <- 100
# RUN SIMULATION ----------------------------------------------------------
#generate initial songs
songs <- sapply(1:n_songs, function(x){paste0(sample(states, ceiling(rnorm(1, m_length, sd_length)), replace = TRUE), collapse = "")})
#initialize population of birds
birds <- data.table::data.table(songs = lapply(1:n_birds, function(x){sample(songs, ceiling(truncnorm::rtruncnorm(1, a = 0, b = n_songs - 1, mean = m_rep, sd = sd_rep)))}))
#create output vector
output <- list()
for(i in 1:t){
#get number of new birds who will learn
babies <- n_birds*turnover
#get population of new birds, sampling songs from existing birds
new_birds <- data.table::data.table(songs = lapply(1:babies, function(x){
to_learn <- as.data.frame(table(unlist(birds$songs[sample(nrow(birds), dems)])))
as.character(sample(to_learn$Var1, ceiling(truncnorm::rtruncnorm(1, a = 1, b = nrow(to_learn) - 1, mean = m_rep, sd = sd_rep)), prob = to_learn$Freq))
}))
#boolean vector of songs
innov_bools <- sapply(1:sum(lengths(new_birds$songs)), function(x){sample(c(TRUE, FALSE), 1, prob = c(mu, 1 - mu))})
#create data frame to navigate list of lists
list_nav <- data.frame(x = rep(c(1:nrow(new_birds)), lengths(new_birds$songs)), y = unlist(sapply(1:length(lengths(new_birds$songs)), function(x){c(1:(lengths(new_birds$songs)[x]))})))
#subset list_nav using innov_bools
to_innov <- list_nav[which(innov_bools), ]
#for each song to be innovated
for(j in 1:nrow(to_innov)){
#store sequence to edit
sequence <- new_birds$songs[[to_innov$x[j]]][to_innov$y[j]]
sequence <- strsplit(sequence, "")[[1]]
#generate 100 edits and calculate entropies
edits <- lapply(1:100, function(x){edit(states, sequence)})
entropies <- sapply(1:length(edits), function(x){entropy(edits[[x]])})
#sample edits, weighted by entropies, and overwrite previous sequence
new_birds$songs[[to_innov$x[j]]][to_innov$y[j]] <- paste0(sample(edits, 1, prob = entropies^pref_strength)[[1]], collapse = "")
}
#add new_birds to birds
birds <- data.table::rbindlist(list(birds, new_birds))
#mortality
birds <- birds[-sample(1:nrow(birds), babies), ]
#store entropy of current songs in output
output[[i]] <- sapply(1:length(unlist(birds$songs)), function(x){entropy(strsplit(unlist(birds$songs)[x], "")[[1]])})
}
#print mean entropy over time
sapply(1:length(output), function(x){mean(output[[x]])})
#colors for plotting after each timepoint
colors <- rainbow(t*1.25) #times 1.2 so it doesn't loop back around
#parameters for plotting
bw <- 0.05
buffer <- 0.05
ymax <- 8
for(i in 1:length(output)){
if(i == 1){
par(mar = c(4, 4, 1, 1))
plot(density(output[[i]], bw = bw), xlab = "Entropy", main = "", xlim = c(min(unlist(output))-(min(unlist(output))*buffer), max(unlist(output))+(max(unlist(output))*buffer)), ylim = c(0, ymax))
}
if(i > 1){lines(density(output[[i]], bw = bw)$x, density(output[[i]], bw = bw)$y, type = "l", col = colors[i-1])}
}
?abc::abc
#load packages
library(data.table)
library(ggplot2)
library(ggfortify)
library(abcrf)
library(EasyABC)
library(abc)
library(tuneRanger)
#set working directory, load data, etc.
setwd("~/Documents/Work/Summer_2021/Cattle_Brands/CattleBrandABM")
load("converted_brands.RData")
load("components.RData")
load("location_data/all_zips.RData")
load("analysis/prior_simulations.RData")
load("analysis/prior_simulations_angles.RData")
source("cattlebrandABM.R")
#separate brands data by year
brands_1990 <- data.table::data.table(brands[which(brands[, 10] == 1990), 1:9])
brands_2008 <- data.table::data.table(brands[which(brands[, 10] == 2008), 1:9])
brands_2014 <- data.table::data.table(brands[which(brands[, 10] == 2014), 1:9])
brands_2015 <- data.table::data.table(brands[which(brands[, 10] == 2015), 1:9])
brands_2016 <- data.table::data.table(brands[which(brands[, 10] == 2016), 1:9])
#get vector of observed summary statistics
obs_stats <- c(get_sum_stats(as.matrix(brands_2008), components, all_zips, angles = FALSE),
get_sum_stats(as.matrix(brands_2014), components, all_zips, angles = FALSE),
get_sum_stats(as.matrix(brands_2015), components, all_zips, angles = FALSE),
get_sum_stats(as.matrix(brands_2016), components, all_zips, angles = FALSE))
#convert to data frame with same structure as vector of observed summary statistics
sum_stats_a <- do.call("rbind", lapply(1:length(prior_simulations$sum_stats), function(x){c(t(as.matrix(prior_simulations$sum_stats[[x]])))}))
sum_stats_b <- do.call("rbind", lapply(1:length(prior_simulations_angles$sum_stats), function(x){c(t(as.matrix(prior_simulations_angles$sum_stats[[x]])))}))
#normal abc
abc(target = obs_stats, param = prior_simulations$priors, sumstat = sum_stats_a)
#normal abc
test <- abc(target = obs_stats, param = prior_simulations$priors, sumstat = sum_stats_a, tol = 0.05)
#normal abc
test <- abc(target = obs_stats, param = prior_simulations$priors, sumstat = sum_stats_a, tol = 0.05, method = "rejection")
sum_stats_a
#normal abc
test <- abc(target = obs_stats, param = prior_simulations$priors, sumstat = as.data.frame(sum_stats_a), tol = 0.05, method = "rejection")
plot(test)
hist(test)
hist(test, breaks = 100)
test <- abc(target = obs_stats, param = prior_simulations$priors, sumstat = as.data.frame(sum_stats_a), tol = 0.01, method = "rejection")
hist(test, breaks = 100)
hist(test, breaks = 100)
