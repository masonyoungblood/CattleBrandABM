census_names <- read.csv("Names_2010Census.csv")
#replace "(S)" in the census table with 0
breakdown_matrix <- as.matrix(census_names[, 6:11])
breakdown_matrix[which(breakdown_matrix == "(S)")] <- 0
census_names[, 6:11] <- breakdown_matrix
#replace census table with adjusted counts by race
census_names <- data.frame(letter = substr(census_names$name, 1, 1),
num_white = census_names$count*as.numeric(census_names$pctwhite),
num_black = census_names$count*as.numeric(census_names$pctblack),
num_api = census_names$count*as.numeric(census_names$pctapi),
num_na = census_names$count*as.numeric(census_names$pctaian),
num_mult = census_names$count*as.numeric(census_names$pct2prace),
num_hisp = census_names$count*as.numeric(census_names$pcthispanic))
#aggregate by letter
census_names <- aggregate(. ~ letter, data = census_names, sum)
#load in target racial breakdown for KS, which does not add up to 100% because of overlap (white, black, asian + pacific islander, native american, 2+, hispanic): https://www.census.gov/quickfacts/KS
ks_breakdown <- 2913314*c(0.863, 0.061, 0.033, 0.012, 0.031, 0.122)
#construct data frame for plotting
letter_data <- data.frame(letter = LETTERS,
name_freq = sapply(1:nrow(census_names), function(x){sum(census_names[x, 2:7])}),
adj_name_freq = sapply(1:nrow(census_names), function(x){sum(ks_breakdown/census_names[x, 2:7])}))
#plot name data
ggplot2::ggplot(data = letter_data, ggplot2::aes(x = letter, y = name_freq)) +
ggplot2::geom_bar(stat = "identity") +
ggplot2::theme_linedraw() +
ggplot2::labs(x = "Letter", y = "Frequency", title = "Surnames")
#plot adjusted name data
#ggplot2::ggplot(data = letter_data, ggplot2::aes(x = letter, y = adj_name_freq)) +
#  ggplot2::geom_bar(stat = "identity") +
#  ggplot2::theme_linedraw() +
#  ggplot2::labs(x = "Letter", y = "Adjusted Frequency", title = "Surnames")
rm(list = c("census_names", "breakdown_matrix", "ks_breakdown", "letter_data"))
#load in the checked brands with letters and get the proportion correct
prop_correct <- mean(read.csv("letters_checked.csv")$initials)*100
#load in adjustments from components.xlsx
collapse <- data.table::as.data.table(readxl::read_excel(paste0(dirname(rstudioapi::getSourceEditorContext()$path), "/", "components.xlsx"), sheet = "collapse"))
rotation <- data.table::as.data.table(readxl::read_excel(paste0(dirname(rstudioapi::getSourceEditorContext()$path), "/", "components.xlsx"), sheet = "rotation"))
#reformat rotation
rotation$rot <- strsplit(rotation$rot, ", ")
#store components with commas
components <- stringr::str_pad(rotation$component, width = 3, side = "right", pad = ",")
#print them
components
load("location_data/all_zips.RData")
load("location_data/zip_dists.RData")
concat_brands <- sapply(1:nrow(brands), function(x){
#get four components and the duplicate code
temp <- brands$brand[[x]][c(1:4, 6)]
#if duplicate code is missing them remove the NA
if(length(which(is.na(temp))) > 0){
temp <- temp[-which(is.na(temp))]
}
#return a concatenated version
paste0(temp, collapse = "")
})
#build data table to determine which rows are duplicated (accounting for zip code and year)
concat_brands <- data.table::data.table(brand = concat_brands, location = brands$location, year = brands$year)
which(is.na(concat_brands$brand))
#remove duplicated rows from the main data table
brands <- brands[-which(duplicated(concat_brands)),]
#remove temporary object
rm(concat_brands)
brands
#create empty matrix for converted brands
converted_brands <- matrix(0, nrow = nrow(brands), ncol = 10)
#append zip codes and years
converted_brands[, 9] <- as.numeric(brands$location)
converted_brands[, 10] <- as.numeric(brands$year)
#create empty matrix for converted brands
converted_brands <- matrix(0, nrow = nrow(brands), ncol = 10)
brands$location
#read in brand data
brands <- read.csv("brand_data.csv")[, -1]
#remove brands with length of 12 (incorrectly specified according to manual inspection)
brands <- brands[-which(nchar(brands$brand) == 12), ]
#substring brand codes into vector of four components and one location
brands$brand <- lapply(1:nrow(brands), function(x){substring(brands$brand[[x]], first = c(1, 4, 7, 10, 13), last = c(3, 6, 9, 12, 13))})
#print a sample
brands[1:10, ]
#move duplicate code (12th position) into the sixth position of the brand vectors
for(x in 1:nrow(brands)){
#if fourth position starts with a comma and ends with a number (or O)
if(substring(brands$brand[[x]][4], 1, 1) == "," & substring(brands$brand[[x]][4], 3) %in% c("O", 0:9)){
#put duplicate number into the sixth position
brands$brand[[x]][6] <- gsub(",", "", brands$brand[[x]][4])
#replace any O with 0
brands$brand[[x]][6] <- gsub("O", 0, brands$brand[[x]][6])
#replace original fourth position with ",,,"
brands$brand[[x]][4] <- ",,,"
}
}
#save
save(brands, file = "raw_brands.RData")
#load in adjustments from components.xlsx
collapse <- data.table::as.data.table(readxl::read_excel(paste0(dirname(rstudioapi::getSourceEditorContext()$path), "/", "components.xlsx"), sheet = "collapse"))
rotation <- data.table::as.data.table(readxl::read_excel(paste0(dirname(rstudioapi::getSourceEditorContext()$path), "/", "components.xlsx"), sheet = "rotation"))
#reformat rotation
rotation$rot <- strsplit(rotation$rot, ", ")
#for each brand
for(i in 1:nrow(brands)){
#check if there are characters that need replacing (either three digit characters like BX1 and QC1 or substringed characters without commas)
temp <- which(brands$brand[[i]][1:4] %in% collapse$from | gsub(",", "", substr(brands$brand[[i]][1:4], 1, 2)) %in% collapse$from)
#and if there are
if(length(temp) > 0){
#go through them
for(j in 1:length(temp)){
#if the full three-digit component is in the data table (so something like BX1, QC1, etc.)
if(brands$brand[[i]][temp[j]] %in% collapse$from){
#store the index of the component
temp_2 <- which(collapse$from == brands$brand[[i]][temp[j]])
#and either replace it without or with rotation
if(collapse$rot[temp_2] == "NA"){
brands$brand[[i]][temp[j]] <- stringr::str_pad(collapse$to[temp_2], width = 3, side = "right", pad = ",")
} else{
brands$brand[[i]][temp[j]] <- paste0(stringr::str_pad(collapse$to[temp_2], width = 2, side = "right", pad = ","), collapse$rot[temp_2])
}
} else{ #if it's less than three digits
#store the index of the component
temp_2 <- which(collapse$from == gsub(",", "", substr(brands$brand[[i]][temp[j]], 1, 2)))
#and either replace it without or with rotation
if(collapse$rot[temp_2] == "NA"){
brands$brand[[i]][temp[j]] <- stringr::str_pad(collapse$to[temp_2], width = 3, side = "right", pad = ",")
} else{
brands$brand[[i]][temp[j]] <- paste0(stringr::str_pad(collapse$to[temp_2], width = 2, side = "right", pad = ","), collapse$rot[temp_2])
}
}
rm(temp_2)
}
}
rm(temp)
}
#for each brand
for(i in 1:nrow(brands)){
#check if there are rotated components
temp <- which(substr(brands$brand[[i]][1:4], 3, 3) %in% c(1:9))
#if there are
if(length(temp) > 0){
#go through them
for(j in 1:length(temp)){
#store the index of the component
temp_2 <- which(rotation$component == gsub(",", "", substr(brands$brand[[i]][temp[j]], 1, 2)))
#store the current angle of rotation
angle <- substr(brands$brand[[i]][temp[j]], 3, 3)
#if the rotated component matches a real component (checking since we haven't removed misspecified components yet)
if(length(temp_2) > 0){
#and the rotation angle is not in the first unique rotation angles for that component
if(!(angle %in% rotation$rot[[temp_2]])){
#and the new rotation is not zero
if(as.numeric(rotation[temp_2, ..angle]) > 0){
#replace the current rotated component with a corrected version
brands$brand[[i]][temp[j]] <- paste0(substr(brands$brand[[i]][temp[j]], 1, 2), as.numeric(rotation[temp_2, ..angle]))
} else{ #if the new rotation is zero
#remove the rotation entirely
brands$brand[[i]][temp[j]] <- paste0(substr(brands$brand[[i]][temp[j]], 1, 2), ",")
}
}
}
rm(list = c("temp_2", "angle"))
}
}
rm(temp)
}
#store components with commas
components <- stringr::str_pad(rotation$component, width = 3, side = "right", pad = ",")
#print them
components
#create empty vectors to fill
all_poss_components <- c()
index_components <- c()
#iterate through components
for(x in 1:length(components)){
#if the component is not rotatable
if(length(which(rotation$rot[[x]] == "NA")) > 0){
#add it without rotation
all_poss_components <- c(all_poss_components, components[x])
index_components <- c(index_components, components[x])
} else{
#add it with rotation
all_poss_components <- c(all_poss_components, components[x], paste0(substr(components[x], 1, 2), rotation$rot[[x]]))
index_components <- c(index_components, components[x], rep(components[x], length(paste0(substr(components[x], 1, 2), rotation$rot[[x]]))))
}
}
#combine new vectors into a data frame and remove old variable
all_poss_components <- data.frame(index = index_components, rot = all_poss_components)
rm(index_components)
#remove all misspecified brands (with components that aren't letters or don't appear in all possible components)
misspecified <- which(sapply(1:nrow(brands), function(x){
length(which(brands$brand[[x]][1:4] %in% c(all_poss_components$rot, ",,,")))
}) != 4)
brands <- brands[-misspecified,]
rm(misspecified)
#get all kansas zip codes
data("zip_code_db", package = "zipcodeR")
zip_code_db <- zip_code_db[which(zip_code_db$state == "KS"), ]
#identify zip codes with missing location data
missing_locations <- which(is.na(zip_code_db$lat))
#save zip codes with missing locations, to manually fill as CSV file outside of R using Google Maps
#sink("location_data/missing_zips.txt")
#cat(zip_code_db$zipcode[missing_locations], sep = "\n")
#sink()
#add in found locations
found <- read.csv("location_data/missing_zips_found.txt", header = FALSE)
zip_code_db$lat[missing_locations] <- found$V2
zip_code_db$lng[missing_locations] <- found$V3
#construct all_zips, a data table with zip codes, counties, latitudes, and longitudes
all_zips <- data.table::data.table(zip = as.numeric(zip_code_db$zipcode), county = as.factor(zip_code_db$county), lat = zip_code_db$lat, lon = zip_code_db$lng)
#save
save(all_zips, file = "location_data/all_zips.RData")
#subset brands to only include those from kansas
brands <- brands[which(brands$location %in% all_zips$zip), ]
#remove temporary objects
rm(list = c("zip_code_db", "missing_locations", "found"))
load("location_data/all_zips.RData")
load("location_data/zip_dists.RData")
#get concatenated brands with duplicate codes
concat_brands <- sapply(1:nrow(brands), function(x){
#get four components and the duplicate code
temp <- brands$brand[[x]][c(1:4, 6)]
#if duplicate code is missing them remove the NA
if(length(which(is.na(temp))) > 0){
temp <- temp[-which(is.na(temp))]
}
#return a concatenated version
paste0(temp, collapse = "")
})
#build data table to determine which rows are duplicated (accounting for zip code and year)
concat_brands <- data.table::data.table(brand = concat_brands, location = brands$location, year = brands$year)
#remove duplicated rows from the main data table
brands <- brands[-which(duplicated(concat_brands)),]
#remove temporary object
rm(concat_brands)
brands[1:40,]
#create empty matrix for converted brands
converted_brands <- matrix(0, nrow = nrow(brands), ncol = 10)
#append zip codes and years
converted_brands[, 9] <- as.numeric(brands$location)
converted_brands[, 10] <- as.numeric(brands$year)
#iterate through the brands
for(i in 1:nrow(brands)){
#extract the index numbers of components (ignoring rotation), and replace empty values with 0
brand_nums <- match(all_poss_components$index[match(brands$brand[[i]][1:4], all_poss_components$rot)], components)
brand_nums[is.na(brand_nums)] <- 0
#create empty vector of angles
angle_nums <- rep(0, 4)
#iterate through the components
for(j in 1:length(brand_nums[!is.na(brand_nums)])){
#if the component is not a letter
#check if there are any characters that are different between the actual component and it's index (indicates rotation)
temp <- as.numeric(setdiff(strsplit(all_poss_components$rot[match(brands$brand[[i]][j], all_poss_components$rot)], split = "")[[1]],
strsplit(all_poss_components$index[match(brands$brand[[i]][j], all_poss_components$rot)], split = "")[[1]]))
#if there are, replace the corresponding 0 in the vector of angles
if(length(temp) > 0){angle_nums[j] <- temp}
}
#store numeric brands and angles in the matrix
converted_brands[i, 1:4] <- brand_nums
converted_brands[i, 5:8] <- angle_nums
#remove temporary objects
rm(list = c("brand_nums", "angle_nums", "temp"))
}
#rewrite brands and remove original brands
brands <- converted_brands
rm(converted_brands)
#save
save(brands, file = "converted_brands.RData")
brands[1:10,]
brands[1:40,]
#create data table of counties
counties <- tigris::list_counties("KS")
counties <- data.table::data.table(county = counties$county, quadrant = rep(NA, nrow(counties)))
#NW counties
counties$quadrant[which(counties$county %in% c("Cheyenne", "Rawlins", "Decatur",
"Norton", "Phillips", "Smith",
"Sherman", "Thomas", "Sheridan",
"Graham", "Rooks", "Osborne",
"Wallace", "Logan", "Gove",
"Trego", "Ellis", "Russell"))] <- "NW"
#SW counties
counties$quadrant[which(counties$county %in% c("Greeley", "Wichita", "Scott",
"Lane", "Ness", "Rush", "Barton",
"Hamilton", "Kearny", "Finney",
"Hodgeman", "Pawnee", "Stafford",
"Stanton", "Grant", "Haskell",
"Gray", "Ford", "Edwards",
"Kiowa", "Pratt", "Morton",
"Stevens", "Seward", "Meade",
"Clark", "Comanche", "Barber"))] <- "SW"
#NE counties
counties$quadrant[which(counties$county %in% c("Jewell", "Republic",
"Washington", "Marshall",
"Nemaha", "Brown", "Doniphan",
"Mitchell", "Cloud", "Clay",
"Riley", "Pottawatomie",
"Jackson", "Atchison",
"Jefferson", "Leavenworth",
"Wyandotte", "Lincoln", "Ottawa",
"Ellsworth", "Saline",
"Dickinson", "Geary", "Morris",
"Wabaunsee", "Shawnee", "Osage",
"Douglas", "Franklin", "Johnson",
"Miami"))] <- "NE"
#SE counties
counties$quadrant[which(counties$county %in% c("Rice", "McPherson", "Marion",
"Chase", "Lyon", "Coffey",
"Anderson", "Linn", "Reno",
"Harvey", "Kingman", "Sedgwick",
"Butler", "Greenwood", "Woodson",
"Allen", "Bourbon", "Elk",
"Wilson", "Neosho", "Crawford",
"Harper", "Sumner", "Cowley",
"Chautauqua", "Montgomery",
"Labette", "Cherokee"))] <- "SE"
#add zip codes to data table
data("zip_code_db", package = "zipcodeR")
counties$zip <- lapply(1:nrow(counties), function(x){zipcodeR::search_county(counties$county[x], state_abb = "KS")$zipcode})
#create a thesaurus of which zip codes are in which quadrants
quad_inds <- c()
quad_zips <- c()
for(i in 1:nrow(counties)){
quad_inds <- c(quad_inds, rep(counties$quadrant[i], length(counties$zip[[i]])))
quad_zips <- c(quad_zips, counties$zip[[i]])
}
quad_thes <- data.frame(quadrant = quad_inds, zip = quad_zips)
rm(list = c("quad_inds", "quad_zips"))
#get quadrant for each brand in the dataset
brands_quadrants <- quad_thes$quadrant[match(brands[, 9], quad_thes$zip)]
#get number of components per brand
n_components <- sapply(1:nrow(brands), function(x){4 - length(which(brands[x, 1:4] == 0))})
n_components
#get number of old and young brands for each two- and three-component brand (removing duplicated means young brands don't appear in 1990)
old_2 <- length(which(brands[which(n_components == 2), 10] == 1990))
old_3 <- length(which(brands[which(n_components == 3), 10] == 1990))
old_2
old_3
old_2
old_3
brands
brands
data.table::as.data.table(brands[, 1:9])
duplicated(data.table::as.data.table(brands[, 1:9]))
which(duplicated(data.table::as.data.table(brands[, 1:9])))
brands[1,]
brands[1, ]
paste0(brands[1, ], collapse = " ")
paste0(brands[1, ], collapse = " ")
paste0(brands[1, 1:9], collapse = " ")
paste0(brands[, 1:9], collapse = " ")
paste0(brands1, 1:9], collapse = " ")
paste0(brands[1, 1:9], collapse = " ")
sapply(1:nrow(brands), function(x){paste0(brands[x, 1:9], collapse = " ")})
concat_brands <- sapply(1:nrow(brands), function(x){paste0(brands[x, 1:9], collapse = " ")})
concat_brands
unique(concat_brands)
concat_brands <- sapply(1:nrow(brands), function(x){paste0(brands[x, 1:9], collapse = " ")})
as.factor(concat_brands)
concat_brands <- sapply(1:nrow(brands), function(x){paste0(brands[x, 1:9], collapse = " ")})
length(unique(concat_brands))
concat_brands <- as.factor(sapply(1:nrow(brands), function(x){paste0(brands[x, 1:9], collapse = " ")}))
concat_brands
#get number of two- and three-component brand that are unique to 1990 (old) or unique to the later years (young)
concat_brands <- as.factor(sapply(1:nrow(brands), function(x){paste0(brands[x, 1:9], collapse = " ")}))
concat_brands
#get number of two- and three-component brand that are unique to 1990 (old) or unique to the later years (young)
concat_brands <- as.factor(sapply(1:nrow(brands), function(x){paste0(brands[x, 1:8], collapse = " ")}))
concat_brands
levels(concat_brands)
concat_brands
#get number of two- and three-component brand that are unique to 1990 (old) or unique to the later years (young)
concat_brands <- as.factor(sapply(1:nrow(brands), function(x){paste0(brands[x, 1:8], collapse = " ")}))
#get number of two- and three-component brand that are unique to 1990 (old) or unique to the later years (young)
concat_brands <- as.factor(sapply(1:nrow(brands), function(x){paste0(brands[x, 1:8], collapse = " ")}))
unique_concat_brands <- levels(concat_brands)
unique_concat_brands
length(concat_brands)
unique_concat_brands[1]
which(concat_brands == unique_concat_brands[1])
which(concat_brands == unique_concat_brands[2])
which(concat_brands == unique_concat_brands[3])
which(concat_brands == unique_concat_brands[4])
brands[, 10][which(concat_brands == unique_concat_brands[4])]
brands[which(concat_brands == unique_concat_brands[4]), 10]
unique(brands[which(concat_brands == unique_concat_brands[4]), 10])
lapply(unique_concat_brands, function(x){unique(brands[which(concat_brands == x), 10])})
years_appear <- lapply(unique_concat_brands, function(x){unique(brands[which(concat_brands == x), 10])})
years_appear
sapply(1:length(years_appear), function(x){years_appear[[x]] == 1990})
sapply(1:length(years_appear), function(x){years_appear[[x]] == c(1990)})
sapply(1:length(years_appear), function(x){years_appear[x] == c(1990)})
sapply(1:length(years_appear), function(x){years_appear[[x]] == 1990})
years_appear[999]
years_appear[[999]]
years_appear[[999]] == 1990
sum(years_appear[[999]] == 1990)
years_appear[[999]] == 1990
?all
all(years_appear[[999]] == 1990)
all(years_appear[[999]] == 1990)
sapply(1:length(years_appear), function(x){all(years_appear[[x]] == 1990)})
which(sapply(1:length(years_appear), function(x){all(years_appear[[x]] == 1990)}))
which(sapply(1:length(years_appear), function(x){all(years_appear[[x]] == 1990)}))
years_appear[[999]]
years_appear[[999]] == 1990
years_appear[[999]] != 1990
all(years_appear[[999]] != 1990)
which_old <- which(sapply(1:length(years_appear), function(x){all(years_appear[[x]] == 1990)}))
which_young <- which(sapply(1:length(years_appear), function(x){all(years_appear[[x]] != 1990)}))
which_old
which_young
which_old
which(young)
which_young
which(n_components == 2)
which(n_components == 2) & which_old
which(unique_concat_brands == concat_brands[1])
which(unique_concat_brands == concat_brands[3])
which(unique_concat_brands == concat_brands[4])
which(unique_concat_brands == concat_brands[5])
which(unique_concat_brands == concat_brands[12])
which(unique_concat_brands == concat_brands[14])
which(unique_concat_brands == concat_brands[20])
years_appear[which(unique_concat_brands == concat_brands[20])]
years_appear[[which(unique_concat_brands == concat_brands[20])]]
years_appear[[which(unique_concat_brands == concat_brands[1])]]
years_appear[[which(unique_concat_brands == concat_brands[2])]]
years_appear[[which(unique_concat_brands == concat_brands[3])]]
years_appear[[which(unique_concat_brands == concat_brands[5])]]
years_appear[[which(unique_concat_brands == concat_brands[10])]]
years_appear
years_appear[[which(unique_concat_brands == concat_brands[1000])]]
years_appear[[which(unique_concat_brands == concat_brands[1001])]]
years_appear[[which(unique_concat_brands == concat_brands[1021])]]
years_appear[[which(unique_concat_brands == concat_brands[1031])]]
years_appear[[which(unique_concat_brands == concat_brands[1041])]]
years_appear[[which(unique_concat_brands == concat_brands[1051])]]
years_appear[[which(unique_concat_brands == concat_brands[1052])]]
years_appear[[which(unique_concat_brands == concat_brands[1053])]]
years_appear[[which(unique_concat_brands == concat_brands[1054])]]
#now, we can get which brands are either only old or only young
which_old <- which(sapply(1:length(concat_brands), function(x){all(years_appear[[which(unique_concat_brands == concat_brands[x])]] == 1990)}))
which_young <- which(sapply(1:length(concat_brands), function(x){all(years_appear[[which(unique_concat_brands == concat_brands[x])]] != 1990)}))
which_old
which_young
which_old
which_young
which(n_components = 2) & which_old
which(n_components == 2) & which_old
length(n_components)
which_old <- sapply(1:length(concat_brands), function(x){all(years_appear[[which(unique_concat_brands == concat_brands[x])]] == 1990)})
which_young <- sapply(1:length(concat_brands), function(x){all(years_appear[[which(unique_concat_brands == concat_brands[x])]] != 1990)})
which_old
which_young
n_components == 2
n_components == 2 & which_old
which(n_components == 2 & which_old)
length(which(n_components == 2 & which_old))
length(which(n_components == 3 & which_old))
length(which_old)
which(which(which_old))
length(which(which_old))
length(which_old)
length(which(which_old))
length(which(which_young))
length(which(n_components == 3 & which_old))
length(which(n_components == 2 & which_old))
#finally, we can calculate the numbers
old_2 <- length(which(n_components == 2 & which_old))
old_3 <- length(which(n_components == 3 & which_old))
young_2 <- length(which(n_components == 2 & which_young))
young_3 <- length(which(n_components == 3 & which_young))
old_2
old_3
young_2
young_3
#what percent of component types are singletons
all_components <- c(brands[, 1:4])
all_components <- all_components[-which(all_components == 0)]
percent_singleton <- round((length(which(as.numeric(table(all_components)) == 1))/length(as.numeric(table(all_components))))*100, 2)
percent_singleton
#get quadrant for each two- and three-component brand
table(brands_quadrants[which(n_components == 2)])
table(brands_quadrants[which(n_components == 3)])
table(brands_quadrants[which(n_components == 2 & which_old)])
table(brands_quadrants[which(n_components == 3 & which_old)])
as.numeric(table(brands_quadrants[which(n_components == 2 & which_old)]))
as.numeric(table(brands_quadrants[which(n_components == 3 & which_old)]))
as.numeric(table(brands_quadrants[which(n_components == 2 & which_old)]))
as.numeric(table(brands_quadrants[which(n_components == 3 & which_old)]))
as.numeric(table(brands_quadrants[which(n_components == 2 & which_young)]))
as.numeric(table(brands_quadrants[which(n_components == 3 & which_young)]))
rbind(as.numeric(table(brands_quadrants[which(n_components == 2 & which_old)])),
as.numeric(table(brands_quadrants[which(n_components == 3 & which_old)])),
as.numeric(table(brands_quadrants[which(n_components == 2 & which_young)])),
as.numeric(table(brands_quadrants[which(n_components == 3 & which_young)])))
sample_table <- rbind(as.numeric(table(brands_quadrants[which(n_components == 2 & which_old)])),
as.numeric(table(brands_quadrants[which(n_components == 3 & which_old)])),
as.numeric(table(brands_quadrants[which(n_components == 2 & which_young)])),
as.numeric(table(brands_quadrants[which(n_components == 3 & which_young)])))
sample_table
as.data.frame(sample_table)
sample_table <- as.data.frame(sample_table)
sample_table
table(brands_quadrants[which(n_components == 2 & which_old)])
table(brands_quadrants[which(n_components == 3 & which_old)])
table(brands_quadrants[which(n_components == 3 & which_young)])
table(brands_quadrants[which(n_components == 2 & which_young)])
colnames(sample_table) <- c("NE", "NW", "SE", "SW")
rownames(sample_table) <- c("2-comp old", "3-comp old", "2-comp young", "3-comp young")
sample_table
n_components
n_components == 4
which(n_components == 4)
length(which(n_components == 4))
length(which(n_components == 4))/length(n_components)
