#copy from previous generation
set(population, j = "trait", value = sapply(1:N, function(x){sample(c("A", "B"), 1, prob = probs[[x]])}))
population$trait
N <- 100
t_max <- 100
#create population
population <- data.table(trait = sample(c("A", "B"), N, replace = TRUE))
#create output object
output <- rep(NA, t_max)
output[1] <- sum(population$trait == "A")/N
#agent based model loop
for(i in 2:t_max){
#calculate probabilities
probs <- lapply(1:N, function(x){as.numeric(table(factor(population$trait, levels = c("A", "B"))))})
#copy from previous generation
set(population, j = "trait", value = sapply(1:N, function(x){sample(c("A", "B"), 1, prob = probs[[x]])}))
#get p and put it into the output slot for this generation t
output[i] <- sum(population$trait == "A")/N
}
output
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 1), ylim = c(0, 1))
#load packages
library(data.table)
library(parallel)
library(igraph)
library(scales)
#cultural transmission function
transmission <- function(N = 100, p_0 = 0.5, t_max = 100){
#create population
population <- data.table(trait = sample(c("A", "B"), N, replace = TRUE, prob = c(p_0, 1 - p_0)))
#create output object
output <- rep(NA, t_max)
output[1] <- sum(population$trait == "A")/N
#agent based model loop
for(i in 2:t_max){
#calculate probabilities
probs <- lapply(1:N, function(x){as.numeric(table(factor(population$trait, levels = c("A", "B"))))})
#copy from previous generation
set(population, j = "trait", value = sapply(1:N, function(x){sample(c("A", "B"), 1, prob = probs[[x]])}))
#get p and put it into the output slot for this generation t
output[i] <- sum(population$trait == "A")/N
}
}
transmission()
output <- transmission()
output
#cultural transmission function
transmission <- function(N = 100, p_0 = 0.5, t_max = 100){
#create population
population <- data.table(trait = sample(c("A", "B"), N, replace = TRUE, prob = c(p_0, 1 - p_0)))
#create output object
output <- rep(NA, t_max)
output[1] <- sum(population$trait == "A")/N
#agent based model loop
for(i in 2:t_max){
#calculate probabilities
probs <- lapply(1:N, function(x){as.numeric(table(factor(population$trait, levels = c("A", "B"))))})
#copy from previous generation
set(population, j = "trait", value = sapply(1:N, function(x){sample(c("A", "B"), 1, prob = probs[[x]])}))
#get p and put it into the output slot for this generation t
output[i] <- sum(population$trait == "A")/N
}
#return output
return(output)
}
transmission()
transmission()
transmission()
iter <- 10
output <- mclapply(1:iter, function(x){transmission()}, mc.cores = 4)
output
output <- matrix(unlist(output), ncol = iter)
output
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 1), ylim = c(0, 1))
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 1000)}, mc.cores = 4)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
?alpha
as.numeric(table(factor(population$trait, levels = c("A", "B"))))
p_0 <- 0.5
#create population
population <- data.table(trait = sample(c("A", "B"), N, replace = TRUE, prob = c(p_0, 1 - p_0)))
N <- 100
#create population
population <- data.table(trait = sample(c("A", "B"), N, replace = TRUE, prob = c(p_0, 1 - p_0)))
as.numeric(table(factor(population$trait, levels = c("A", "B"))))
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 1000, p_0 = 0.1, content = 1.1)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
warnings()
#cultural transmission function
transmission <- function(N = 100, p_0 = 0.5, t_max = 100, content = 1){
#create population
population <- data.table(trait = sample(c("A", "B"), N, replace = TRUE, prob = c(p_0, 1 - p_0)))
#create output object
output <- rep(NA, t_max)
output[1] <- sum(population$trait == "A")/N
#agent based model loop
for(i in 2:t_max){
#calculate probabilities
probs <- lapply(1:N, function(x){as.numeric(table(factor(population$trait, levels = c("A", "B"))))*c(content, 1)})
#copy from previous generation
set(population, j = "trait", value = sapply(1:N, function(x){sample(c("A", "B"), 1, prob = probs[[x]])}))
#get p and put it into the output slot for this generation t
output[i] <- sum(population$trait == "A")/N
}
#return output
return(output)
}
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 1000, p_0 = 0.1, content = 1.1)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 1000, p_0 = 0.05, content = 1.05)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 100, p_0 = 0.05, content = 1.05)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
c(40, 60)
c(40, 60)^1.5
c(0.4, 0.6)^1.5
c(40, 60)
c(40, 60)^1.5
c(0.4, 0.6)^1.5
c(40, 60)^0.6
c(0.4, 0.6)^0.6
as.numeric(table(factor(population$trait, levels = c("A", "B"))))
as.numeric(table(factor(population$trait, levels = c("A", "B"))))^frequency
frequency <- 1
as.numeric(table(factor(population$trait, levels = c("A", "B"))))^frequency
(as.numeric(table(factor(population$trait, levels = c("A", "B"))))^frequency)*c(content, 1)
#cultural transmission function
transmission <- function(N = 100, p_0 = 0.5, t_max = 100, content = 1, frequency = 1){
#create population
population <- data.table(trait = sample(c("A", "B"), N, replace = TRUE, prob = c(p_0, 1 - p_0)))
#create output object
output <- rep(NA, t_max)
output[1] <- sum(population$trait == "A")/N
#agent based model loop
for(i in 2:t_max){
#calculate probabilities
probs <- lapply(1:N, function(x){(as.numeric(table(factor(population$trait, levels = c("A", "B"))))^frequency)*c(content, 1)})
#copy from previous generation
set(population, j = "trait", value = sapply(1:N, function(x){sample(c("A", "B"), 1, prob = probs[[x]])}))
#get p and put it into the output slot for this generation t
output[i] <- sum(population$trait == "A")/N
}
#return output
return(output)
}
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 1000, p_0 = 0.6, frequency = 1.1)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 1000, p_0 = 0.7, frequency = 0.9)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
transmission <- function(N = 100, p_0 = 0.5, t_max = 100, content = 1, frequency = 1){
#create population
population <- data.table(trait = sample(c("A", "B"), N, replace = TRUE, prob = c(p_0, 1 - p_0)))
#create output object
output <- rep(NA, t_max)
output[1] <- sum(population$trait == "A")/N
#agent based model loop
for(i in 2:t_max){
#calculate probabilities
probs <- lapply(1:N, function(x){(as.numeric(table(factor(population$trait, levels = c("A", "B"))))^frequency)*c(content, 1)})
#copy from previous generation
set(population, j = "trait", value = sapply(1:N, function(x){sample(c("A", "B"), 1, prob = probs[[x]])}))
#get p and put it into the output slot for this generation t
output[i] <- sum(population$trait == "A")/N
}
#return output
return(output)
}
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 1000, p_0 = 0.1, content = 1.1, frequency = 0.8)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
#create matrix of connection probability between clusters
pref_matrix <- matrix(0.01, nrow = 5, ncol = 5)
pref_matrix
diag(pref_matrix) <- 1
pref_matrix
#create and plot population structure
structure <- sample_sbm(100, pref_matrix, rep(100/5, 5))
par(mar = c(0, 0, 0, 0))
plot(structure, vertex.label = NA, vertex.size = 8)
N = 100
p_0 = 0.5
t_max = 100
content = 1
frequency = 1
cluster = 5
edge_prob = 0.01
#create and population structure
pref_matrix <- matrix(edge_prob, nrow = cluster, ncol = cluster)
diag(pref_matrix) <- 1
structure <- sample_sbm(N, pref_matrix, rep(N/cluster, cluster))
#create population
population <- data.table(trait = sample(c("A", "B"), N, replace = TRUE, prob = c(p_0, 1 - p_0)))
population
structure
structure[1]
structure[1] > 0
which(structure[1] > 0)
which(structure[2] > 0)
which(structure[10] > 0)
which(structure[100] > 0)
lapply(1:N, function(x){which(structure[x] > 0)})
#add connections to population table
population$connections <- lapply(1:N, function(x){which(structure[x] > 0)})
population
population$trait
population$connections[[1]]
population$trait[1]
population$trait[c(1, 2, 3)]
population$trait[population$connections[[1]]]
sample(c("A", "B"), N, replace = TRUE, prob = c(p_0, 1 - p_0))
sort(sample(c("A", "B"), N, replace = TRUE, prob = c(p_0, 1 - p_0)))
#cultural transmission function
transmission <- function(N = 100, p_0 = 0.5, t_max = 100, content = 1, frequency = 1, cluster = 5, edge_prob = 0.01){
#create and population structure
pref_matrix <- matrix(edge_prob, nrow = cluster, ncol = cluster)
diag(pref_matrix) <- 1
structure <- sample_sbm(N, pref_matrix, rep(N/cluster, cluster))
#create population
population <- data.table(trait = sort(sample(c("A", "B"), N, replace = TRUE, prob = c(p_0, 1 - p_0))))
#add connections to population table
population$connections <- lapply(1:N, function(x){which(structure[x] > 0)})
#create output object
output <- rep(NA, t_max)
output[1] <- sum(population$trait == "A")/N
#agent based model loop
for(i in 2:t_max){
#calculate probabilities
probs <- lapply(1:N, function(x){(as.numeric(table(factor(population$trait[population$connections[[x]]], levels = c("A", "B"))))^frequency)*c(content, 1)})
#copy from previous generation
set(population, j = "trait", value = sapply(1:N, function(x){sample(c("A", "B"), 1, prob = probs[[x]])}))
#get p and put it into the output slot for this generation t
output[i] <- sum(population$trait == "A")/N
}
#return output
return(output)
}
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 1000, p_0 = 0.6, content = 1, frequency = 1.1,
cluster = 5, edge_prob = 0.01)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 100, p_0 = 0.6, content = 1, frequency = 1.1,
cluster = 5, edge_prob = 0.01)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 500, p_0 = 0.6, content = 1, frequency = 1.1,
cluster = 5, edge_prob = 0.01)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 500, p_0 = 0.6, content = 1, frequency = 1.15,
cluster = 5, edge_prob = 0.01)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 500, p_0 = 0.6, content = 1, frequency = 1.15,
cluster = 5, edge_prob = 0.1)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 500, p_0 = 0.05, content = 1.2, frequency = 1,
cluster = 5, edge_prob = 0.01)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 500, p_0 = 0.05, content = 1.2, frequency = 1,
cluster = 5, edge_prob = 0.1)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
#load packages and data
setwd("~/Documents/Work/Summer_2021/Cattle_Brands/CattleBrandABM")
library(glmmTMB)
library(performance)
library(DHARMa)
library(fitdistrplus)
library(brms)
library(lme4)
library(equatiomatic)
library(rethinking)
load("analysis/shuffling_model/shuffling_data.RData")
#data is zero inflated (8.5% of values)
length(which(shuffling_data$prob_score == 0))/nrow(shuffling_data)
#drop zeroes from the data
shuffling_data <- shuffling_data[-which(shuffling_data$prob_score == 0), ]
#subset for testing
shuffling_data <-  shuffling_data[sample(nrow(shuffling_data), 10000), ]
#convert variables to factors and binarize complexity
shuffling_data$time <- as.factor(shuffling_data$time)
shuffling_data$space <- as.factor(shuffling_data$space)
shuffling_data$brand <- as.factor(shuffling_data$brand)
shuffling_data$brand_num <- as.numeric(shuffling_data$brand)
shuffling_data$mixed <- ifelse(shuffling_data$mixed, 1, 0)
shuffling_data$complexity <- shuffling_data$complexity-2
#scale and log transform the probability score
shuffling_data$prob_score <- scale(log(shuffling_data$prob_score))
#load packages and data
setwd("~/Documents/Work/Summer_2021/Cattle_Brands/CattleBrandABM")
library(glmmTMB)
library(performance)
library(DHARMa)
library(fitdistrplus)
library(brms)
library(lme4)
library(equatiomatic)
library(rethinking)
load("analysis/shuffling_model/shuffling_data.RData")
#data is zero inflated (8.5% of values)
length(which(shuffling_data$prob_score == 0))/nrow(shuffling_data)
#drop zeroes from the data
shuffling_data <- shuffling_data[-which(shuffling_data$prob_score == 0), ]
#convert variables to factors and binarize complexity
shuffling_data$time <- as.factor(shuffling_data$time)
shuffling_data$space <- as.factor(shuffling_data$space)
shuffling_data$brand <- as.factor(shuffling_data$brand)
shuffling_data$brand_num <- as.numeric(shuffling_data$brand)
shuffling_data$mixed <- ifelse(shuffling_data$mixed, 1, 0)
shuffling_data$complexity <- shuffling_data$complexity-2
#scale and log transform the probability score
shuffling_data$prob_score <- scale(log(shuffling_data$prob_score))
#run random effects models
space_model <- lmer(prob_score ~ (1|space), data = shuffling_data)
time_model <- lmer(prob_score ~ (1|time), data = shuffling_data)
brand_model <- lmer(prob_score ~ (1|brand), data = shuffling_data)
#get intra-class coefficients for each random effect
performance::icc(space_model)
performance::icc(time_model)
performance::icc(brand_model)
#add complexity as fixed effect
complexity_model <- lmer(prob_score ~ complexity + (1|brand), data = shuffling_data)
compare_performance(brand_model, complexity_model, metrics = "AIC")
summary(actual_model)
#compare and check the strength of actual
compare_performance(brand_model, complexity_model, metrics = "AIC")
#add actual as fixed effect
actual_model <- lmer(prob_score ~ actual + complexity + (1|brand), data = shuffling_data)
#compare and check the strength of actual
compare_performance(complexity_model, actual_model, metrics = "AIC")
#add interaction between actual and mixed
mixed_model <- lmer(prob_score ~ complexity + actual*mixed + (1|brand), data = shuffling_data)
#compare and check the strength of interaction
compare_performance(actual_model, mixed_model, metrics = "AIC")
#get model estimates from interaction model
summary(mixed_model)
confint(mixed_model)
#check of residuals using DHARMa
model_mixed_simres <- simulateResiduals(model_mixed)
#check of residuals using DHARMa
mixed_model_simres <- simulateResiduals(mixed_model)
?simulateResiduals
shuffling_data$prob_score
setwd("~/Documents/Work/Summer_2021/Cattle_Brands/CattleBrandABM")
library(performance)
library(DHARMa)
library(lme4)
load("analysis/shuffling_model/shuffling_data.RData")
#data is zero inflated (8.5% of values)
length(which(shuffling_data$prob_score == 0))/nrow(shuffling_data)
#drop zeroes from the data
shuffling_data <- shuffling_data[-which(shuffling_data$prob_score == 0), ]
#convert variables to factors and binarize complexity
shuffling_data$time <- as.factor(shuffling_data$time)
shuffling_data$space <- as.factor(shuffling_data$space)
shuffling_data$brand <- as.factor(shuffling_data$brand)
shuffling_data$brand_num <- as.numeric(shuffling_data$brand)
shuffling_data$mixed <- ifelse(shuffling_data$mixed, 1, 0)
shuffling_data$complexity <- shuffling_data$complexity-2
#scale and log transform the probability score
shuffling_data$prob_score <- as.numeric(scale(log(shuffling_data$prob_score)))
shuffling_data$prob_score
shuffling_data
#run random effects models
space_model <- lmer(prob_score ~ (1|space), data = shuffling_data)
time_model <- lmer(prob_score ~ (1|time), data = shuffling_data)
brand_model <- lmer(prob_score ~ (1|brand), data = shuffling_data)
#add complexity as fixed effect
complexity_model <- lmer(prob_score ~ complexity + (1|brand), data = shuffling_data)
#add actual as fixed effect
actual_model <- lmer(prob_score ~ actual + complexity + (1|brand), data = shuffling_data)
#add interaction between actual and mixed
mixed_model <- lmer(prob_score ~ complexity + actual*mixed + (1|brand), data = shuffling_data)
mixed_model_confints <- confint(mixed_model)
#check of residuals using DHARMa
mixed_model_simres <- simulateResiduals(mixed_model)
plot(mixed_model_simres)
plot(mixed_model_simres)
plot(mixed_model)
plot(mixed_model)
qqnorm(residuals(mixed_model))
testOverdispersion(mixed_model_simres)
list(random_effects = list(space_model = space_model, time_model = time_model, brand_model = brand_model),
fixed_effects = list(actual_model = actual_model, mixed_model = mixed_model),
checks = list(mixed_model_confints = mixed_model_confints, mixed_model_simres = mixed_model_simres))
#save output
glmm_output <- list(random_effects = list(space_model = space_model, time_model = time_model, brand_model = brand_model),
fixed_effects = list(complexity_model = complexity_model, actual_model = actual_model, mixed_model = mixed_model),
checks = list(mixed_model_confints = mixed_model_confints, mixed_model_simres = mixed_model_simres))
save(glmm_output, file = "glmm_output.RData")
#load packages and data
setwd("~/Documents/Work/Summer_2021/Cattle_Brands/CattleBrandABM")
library(performance)
library(DHARMa)
library(lme4)
load("analysis/shuffling_model/shuffling_data.RData")
#data is zero inflated (8.5% of values)
length(which(shuffling_data$prob_score == 0))/nrow(shuffling_data)
#drop zeroes from the data
shuffling_data <- shuffling_data[-which(shuffling_data$prob_score == 0), ]
#convert variables to factors and binarize complexity
shuffling_data$time <- as.factor(shuffling_data$time)
shuffling_data$space <- as.factor(shuffling_data$space)
shuffling_data$brand <- as.factor(shuffling_data$brand)
shuffling_data$brand_num <- as.numeric(shuffling_data$brand)
shuffling_data$mixed <- ifelse(shuffling_data$mixed, 1, 0)
shuffling_data$complexity <- shuffling_data$complexity-2
#scale and log transform the probability score
shuffling_data$prob_score <- as.numeric(scale(log(shuffling_data$prob_score)))
# #run all models
# space_model <- lmer(prob_score ~ (1|space), data = shuffling_data)
# time_model <- lmer(prob_score ~ (1|time), data = shuffling_data)
# brand_model <- lmer(prob_score ~ (1|brand), data = shuffling_data)
# complexity_model <- lmer(prob_score ~ complexity + (1|brand), data = shuffling_data)
# actual_model <- lmer(prob_score ~ actual + complexity + (1|brand), data = shuffling_data)
# mixed_model <- lmer(prob_score ~ complexity + actual*mixed + (1|brand), data = shuffling_data)
#
# #get output required for checks
# mixed_model_confints <- confint(mixed_model)
# mixed_model_simres <- simulateResiduals(mixed_model)
#
# #save output
# glmm_output <- list(random_effects = list(space_model = space_model, time_model = time_model, brand_model = brand_model),
#                     fixed_effects = list(complexity_model = complexity_model, actual_model = actual_model, mixed_model = mixed_model),
#                     checks = list(mixed_model_confints = mixed_model_confints, mixed_model_simres = mixed_model_simres))
# save(glmm_output, file = "analysis/shuffling_model/glmm_output.RData")
#load output
load("analysis/shuffling_model/glmm_output.RData")
glmm_output$random_effects$space_model
#get intra-class coefficients for each random effect
performance::icc(glmm_output$random_effects$space_model)
performance::icc(glmm_output$random_effects$time_model)
performance::icc(glmm_output$random_effects$brand_model)
#compare complexity model with random effects
compare_performance(glmm_output$random_effects$brand_model, glmm_output$fixed_effects$complexity_model, metrics = "AIC")
#compare complexity and actual model
compare_performance(glmm_output$fixed_effects$complexity_model, glmm_output$fixed_effects$actual_model, metrics = "AIC")
