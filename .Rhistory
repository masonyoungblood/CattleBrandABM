sigma ~ dexp(1)
), data = data, chains = 4, cores = 4, log_lik = TRUE)
#run model with density added as
model_dens <- ulam(alist(
S ~ dbinom(D, p),
logit(p) <- a[T] + b[P,G] + b_d[P]*D2,
a[T] ~ dnorm(0, sigma),
matrix[P,G]:b ~ dnorm(0, 1),
b_d[P] ~ dnorm(0, 0.5),
sigma ~ dexp(1)
), data = data, chains = 4, cores = 4, log_lik = TRUE)
#run model with density added as
model_dens <- ulam(alist(
S ~ dbinom(D, p),
logit(p) <- a[T] + b[P,G] + b_d[P]*D,
a[T] ~ dnorm(0, sigma),
matrix[P,G]:b ~ dnorm(0, 1),
b_d[P] ~ dnorm(0, 0.5),
sigma ~ dexp(1)
), data = data, chains = 4, cores = 4, log_lik = TRUE)
#print estimates
precis(model, pars = c("b", "b_d", "sigma"), depth = 3)
#print estimates
precis(model_dens, pars = c("b", "b_d", "sigma"), depth = 3)
#compare sigmas from the two models
precis(model, pars = c("sigma"), depth = 3)
precis(model_dens, pars = c("sigma"), depth = 3)
library(rethinking)
library(dagitty)
# 1 -----------------------------------------------------------------------
#run prior simulation assuming sigma ~ exp(1)
n_sims <- 10000
sigma <- rexp(n_sims, 1)
a_bar <- rnorm(n_sims, 0, 1)
a_j <- rnorm(n_sims, a_bar, sigma)
p <- inv_logit(a_j) #convert to probability scale
dens(p, main = "exp(1)", xlim = c(0, 1))
#run prior simulation assuming sigma ~ exp(10)
n_sims <- 10000
sigma <- rexp(n_sims, 10)
a_bar <- rnorm(n_sims, 0, 1)
a_j <- rnorm(n_sims, a_bar, sigma)
p <- inv_logit(a_j) #convert to probability scale
dens(p, main = "exp(10)", xlim = c(0, 1))
#sigma ~ exp(1) is a much more appropriate prior because it includes a broader range of probabilities
# 2 -----------------------------------------------------------------------
#draw and plot DAG
dag <- dagitty("dag {
T -> S
D -> S
G -> S
P -> S
}")
coordinates(dag) <- list(x = c(T = 1, S = 2, D = 1, G = 2, P = 3),
y = c(T = 2, S = 2, D = 1, G = 1, P = 1))
plot(dag)
#looks like we should include everything! there are not backdoor paths or
#anything else to consider because this is a controlled experiment... density
#will just be included as the number of trials for the binomial distribution
#load data
data("reedfrogs")
data <- reedfrogs
data$tank <- 1:nrow(data)
data$pred <- ifelse(data$pred == "no", 1, 2) #1 = no, 2 = yes
data$size <- ifelse(data$size == "small", 1, 2) #1 = small, 2 = big
data <- list(S = data$surv, D = data$density, T = data$tank, G = data$size, P = data$pred)
#run model
model <- ulam(alist(
S ~ dbinom(D, p),
logit(p) <- a[T] + b[P,G],
a[T] ~ dnorm(0, sigma),
matrix[P,G]:b ~ dnorm(0, 1),
sigma ~ dexp(1)
), data = data, chains = 4, cores = 4, log_lik = TRUE)
#print estimates
precis(model, pars = c("b", "sigma"), depth = 3)
#survival is highest for large tadpoles when predation is low, and only
#slightly lower for smaller tadpoles in the same condition... survival is lowest
#for the big tadpoles when predation is high, and is relatively lower for the
#smaller tadpoles in the same condition... interesting interaction!
# 3 -----------------------------------------------------------------------
#run model with density added as
model_dens <- ulam(alist(
S ~ dbinom(D, p),
logit(p) <- a[T] + b[P,G] + b_d[P]*D,
a[T] ~ dnorm(0, sigma),
matrix[P,G]:b ~ dnorm(0, 1),
b_d[P] ~ dnorm(0, 0.5),
sigma ~ dexp(1)
), data = data, chains = 4, cores = 4, log_lik = TRUE)
#print estimates
precis(model_dens, pars = c("b", "b_d", "sigma"), depth = 3)
#density appears to have a positive effect on survival when predation is low,
#and a negative effect on survival when predation is high
#compare sigmas from the two models
precis(model, pars = c("sigma"), depth = 3)
precis(model_dens, pars = c("sigma"), depth = 3)
#the sigma for the second model is lower than for the first model, which I think
#reflects the fact that the second model accounts for more of the variance in
#the data than the first because it includes density as a predictor
library(data.table)
library(parallel)
library(igraph)
library(scales)
install.packages("data.table")
install.packages("data.table")
#load packages
library(data.table)
library(parallel)
library(igraph)
library(scales)
#set population size
N <- 100
t_max <- 100
population <- data.table(trait = sample(c("A", "B"), N, replace = TRUE))
population
rep(NA, t_max)
#create output object
output <- rep(NA, t_max)
output
sum(population$trait == "A")/N
output[1] <- sum(population$trait == "A")/N
output
2:t_max
population$trait
factor(population$trait, levels = c("A", "B"))
table(factor(population$trait, levels = c("A", "B"))
)
table(factor(population$trait, levels = c("A", "B")))
as.numeric(table(factor(population$trait, levels = c("A", "B"))))
#calculate probabilities
probs <- lapply(1:N, function(x){as.numeric(table(factor(population$trait, levels = c("A", "B"))))})
probs
#calculate probabilities
probs <- lapply(1:N, function(x){as.numeric(table(factor(population$trait, levels = c("A", "B"))))})
prob[[1]]
probs[[1]]
sample(c("A", "B"), 1, prob = probs[[1]])
sample(c("A", "B"), 1, prob = probs[[1]])
sample(c("A", "B"), 1, prob = probs[[1]])
sample(c("A", "B"), 1, prob = probs[[1]])
sample(c("A", "B"), 1, prob = probs[[1]])
sample(c("A", "B"), 1, prob = probs[[1]])
sample(c("A", "B"), 1, prob = probs[[1]])
sample(c("A", "B"), 1, prob = probs[[1]])
sample(c("A", "B"), 1, prob = probs[[1]])
sample(c("A", "B"), 1, prob = probs[[1]])
sapply(1:N, function(x){sample(c("A", "B"), 1, prob = probs[[x]])})
population$trait
#copy from previous generation
set(population, j = "trait", value = sapply(1:N, function(x){sample(c("A", "B"), 1, prob = probs[[x]])}))
population$trait
N <- 100
t_max <- 100
#create population
population <- data.table(trait = sample(c("A", "B"), N, replace = TRUE))
#create output object
output <- rep(NA, t_max)
output[1] <- sum(population$trait == "A")/N
#agent based model loop
for(i in 2:t_max){
#calculate probabilities
probs <- lapply(1:N, function(x){as.numeric(table(factor(population$trait, levels = c("A", "B"))))})
#copy from previous generation
set(population, j = "trait", value = sapply(1:N, function(x){sample(c("A", "B"), 1, prob = probs[[x]])}))
#get p and put it into the output slot for this generation t
output[i] <- sum(population$trait == "A")/N
}
output
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 1), ylim = c(0, 1))
#load packages
library(data.table)
library(parallel)
library(igraph)
library(scales)
#cultural transmission function
transmission <- function(N = 100, p_0 = 0.5, t_max = 100){
#create population
population <- data.table(trait = sample(c("A", "B"), N, replace = TRUE, prob = c(p_0, 1 - p_0)))
#create output object
output <- rep(NA, t_max)
output[1] <- sum(population$trait == "A")/N
#agent based model loop
for(i in 2:t_max){
#calculate probabilities
probs <- lapply(1:N, function(x){as.numeric(table(factor(population$trait, levels = c("A", "B"))))})
#copy from previous generation
set(population, j = "trait", value = sapply(1:N, function(x){sample(c("A", "B"), 1, prob = probs[[x]])}))
#get p and put it into the output slot for this generation t
output[i] <- sum(population$trait == "A")/N
}
}
transmission()
output <- transmission()
output
#cultural transmission function
transmission <- function(N = 100, p_0 = 0.5, t_max = 100){
#create population
population <- data.table(trait = sample(c("A", "B"), N, replace = TRUE, prob = c(p_0, 1 - p_0)))
#create output object
output <- rep(NA, t_max)
output[1] <- sum(population$trait == "A")/N
#agent based model loop
for(i in 2:t_max){
#calculate probabilities
probs <- lapply(1:N, function(x){as.numeric(table(factor(population$trait, levels = c("A", "B"))))})
#copy from previous generation
set(population, j = "trait", value = sapply(1:N, function(x){sample(c("A", "B"), 1, prob = probs[[x]])}))
#get p and put it into the output slot for this generation t
output[i] <- sum(population$trait == "A")/N
}
#return output
return(output)
}
transmission()
transmission()
transmission()
iter <- 10
output <- mclapply(1:iter, function(x){transmission()}, mc.cores = 4)
output
output <- matrix(unlist(output), ncol = iter)
output
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 1), ylim = c(0, 1))
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 1000)}, mc.cores = 4)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
?alpha
as.numeric(table(factor(population$trait, levels = c("A", "B"))))
p_0 <- 0.5
#create population
population <- data.table(trait = sample(c("A", "B"), N, replace = TRUE, prob = c(p_0, 1 - p_0)))
N <- 100
#create population
population <- data.table(trait = sample(c("A", "B"), N, replace = TRUE, prob = c(p_0, 1 - p_0)))
as.numeric(table(factor(population$trait, levels = c("A", "B"))))
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 1000, p_0 = 0.1, content = 1.1)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
warnings()
#cultural transmission function
transmission <- function(N = 100, p_0 = 0.5, t_max = 100, content = 1){
#create population
population <- data.table(trait = sample(c("A", "B"), N, replace = TRUE, prob = c(p_0, 1 - p_0)))
#create output object
output <- rep(NA, t_max)
output[1] <- sum(population$trait == "A")/N
#agent based model loop
for(i in 2:t_max){
#calculate probabilities
probs <- lapply(1:N, function(x){as.numeric(table(factor(population$trait, levels = c("A", "B"))))*c(content, 1)})
#copy from previous generation
set(population, j = "trait", value = sapply(1:N, function(x){sample(c("A", "B"), 1, prob = probs[[x]])}))
#get p and put it into the output slot for this generation t
output[i] <- sum(population$trait == "A")/N
}
#return output
return(output)
}
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 1000, p_0 = 0.1, content = 1.1)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 1000, p_0 = 0.05, content = 1.05)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 100, p_0 = 0.05, content = 1.05)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
c(40, 60)
c(40, 60)^1.5
c(0.4, 0.6)^1.5
c(40, 60)
c(40, 60)^1.5
c(0.4, 0.6)^1.5
c(40, 60)^0.6
c(0.4, 0.6)^0.6
as.numeric(table(factor(population$trait, levels = c("A", "B"))))
as.numeric(table(factor(population$trait, levels = c("A", "B"))))^frequency
frequency <- 1
as.numeric(table(factor(population$trait, levels = c("A", "B"))))^frequency
(as.numeric(table(factor(population$trait, levels = c("A", "B"))))^frequency)*c(content, 1)
#cultural transmission function
transmission <- function(N = 100, p_0 = 0.5, t_max = 100, content = 1, frequency = 1){
#create population
population <- data.table(trait = sample(c("A", "B"), N, replace = TRUE, prob = c(p_0, 1 - p_0)))
#create output object
output <- rep(NA, t_max)
output[1] <- sum(population$trait == "A")/N
#agent based model loop
for(i in 2:t_max){
#calculate probabilities
probs <- lapply(1:N, function(x){(as.numeric(table(factor(population$trait, levels = c("A", "B"))))^frequency)*c(content, 1)})
#copy from previous generation
set(population, j = "trait", value = sapply(1:N, function(x){sample(c("A", "B"), 1, prob = probs[[x]])}))
#get p and put it into the output slot for this generation t
output[i] <- sum(population$trait == "A")/N
}
#return output
return(output)
}
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 1000, p_0 = 0.6, frequency = 1.1)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 1000, p_0 = 0.7, frequency = 0.9)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
transmission <- function(N = 100, p_0 = 0.5, t_max = 100, content = 1, frequency = 1){
#create population
population <- data.table(trait = sample(c("A", "B"), N, replace = TRUE, prob = c(p_0, 1 - p_0)))
#create output object
output <- rep(NA, t_max)
output[1] <- sum(population$trait == "A")/N
#agent based model loop
for(i in 2:t_max){
#calculate probabilities
probs <- lapply(1:N, function(x){(as.numeric(table(factor(population$trait, levels = c("A", "B"))))^frequency)*c(content, 1)})
#copy from previous generation
set(population, j = "trait", value = sapply(1:N, function(x){sample(c("A", "B"), 1, prob = probs[[x]])}))
#get p and put it into the output slot for this generation t
output[i] <- sum(population$trait == "A")/N
}
#return output
return(output)
}
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 1000, p_0 = 0.1, content = 1.1, frequency = 0.8)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
#create matrix of connection probability between clusters
pref_matrix <- matrix(0.01, nrow = 5, ncol = 5)
pref_matrix
diag(pref_matrix) <- 1
pref_matrix
#create and plot population structure
structure <- sample_sbm(100, pref_matrix, rep(100/5, 5))
par(mar = c(0, 0, 0, 0))
plot(structure, vertex.label = NA, vertex.size = 8)
N = 100
p_0 = 0.5
t_max = 100
content = 1
frequency = 1
cluster = 5
edge_prob = 0.01
#create and population structure
pref_matrix <- matrix(edge_prob, nrow = cluster, ncol = cluster)
diag(pref_matrix) <- 1
structure <- sample_sbm(N, pref_matrix, rep(N/cluster, cluster))
#create population
population <- data.table(trait = sample(c("A", "B"), N, replace = TRUE, prob = c(p_0, 1 - p_0)))
population
structure
structure[1]
structure[1] > 0
which(structure[1] > 0)
which(structure[2] > 0)
which(structure[10] > 0)
which(structure[100] > 0)
lapply(1:N, function(x){which(structure[x] > 0)})
#add connections to population table
population$connections <- lapply(1:N, function(x){which(structure[x] > 0)})
population
population$trait
population$connections[[1]]
population$trait[1]
population$trait[c(1, 2, 3)]
population$trait[population$connections[[1]]]
sample(c("A", "B"), N, replace = TRUE, prob = c(p_0, 1 - p_0))
sort(sample(c("A", "B"), N, replace = TRUE, prob = c(p_0, 1 - p_0)))
#cultural transmission function
transmission <- function(N = 100, p_0 = 0.5, t_max = 100, content = 1, frequency = 1, cluster = 5, edge_prob = 0.01){
#create and population structure
pref_matrix <- matrix(edge_prob, nrow = cluster, ncol = cluster)
diag(pref_matrix) <- 1
structure <- sample_sbm(N, pref_matrix, rep(N/cluster, cluster))
#create population
population <- data.table(trait = sort(sample(c("A", "B"), N, replace = TRUE, prob = c(p_0, 1 - p_0))))
#add connections to population table
population$connections <- lapply(1:N, function(x){which(structure[x] > 0)})
#create output object
output <- rep(NA, t_max)
output[1] <- sum(population$trait == "A")/N
#agent based model loop
for(i in 2:t_max){
#calculate probabilities
probs <- lapply(1:N, function(x){(as.numeric(table(factor(population$trait[population$connections[[x]]], levels = c("A", "B"))))^frequency)*c(content, 1)})
#copy from previous generation
set(population, j = "trait", value = sapply(1:N, function(x){sample(c("A", "B"), 1, prob = probs[[x]])}))
#get p and put it into the output slot for this generation t
output[i] <- sum(population$trait == "A")/N
}
#return output
return(output)
}
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 1000, p_0 = 0.6, content = 1, frequency = 1.1,
cluster = 5, edge_prob = 0.01)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 100, p_0 = 0.6, content = 1, frequency = 1.1,
cluster = 5, edge_prob = 0.01)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 500, p_0 = 0.6, content = 1, frequency = 1.1,
cluster = 5, edge_prob = 0.01)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 500, p_0 = 0.6, content = 1, frequency = 1.15,
cluster = 5, edge_prob = 0.01)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 500, p_0 = 0.6, content = 1, frequency = 1.15,
cluster = 5, edge_prob = 0.1)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 500, p_0 = 0.05, content = 1.2, frequency = 1,
cluster = 5, edge_prob = 0.01)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 500, p_0 = 0.05, content = 1.2, frequency = 1,
cluster = 5, edge_prob = 0.1)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
#load packages and data
setwd("~/Documents/Work/Summer_2021/Cattle_Brands/CattleBrandABM")
#library(brms)
library(rstanarm)
load("analysis/shuffling_model/shuffling_data.RData")
#drop zeroes from the data
shuffling_data <- shuffling_data[-which(shuffling_data$prob_score == 0), ]
#convert variables to factors and binarize complexity
shuffling_data$time <- as.factor(shuffling_data$time)
shuffling_data$space <- as.factor(shuffling_data$space)
shuffling_data$brand <- as.factor(shuffling_data$brand)
shuffling_data$brand_num <- as.numeric(shuffling_data$brand)
shuffling_data$mixed <- ifelse(shuffling_data$mixed, 1, 0)
shuffling_data$complexity <- shuffling_data$complexity-2
shuffling_data$inv_complexity <- shuffling_data$complexity*-1
#scale and log transform the probability score
shuffling_data$prob_score <- as.numeric(scale(log(shuffling_data$prob_score)))
library(lme4)
mixed_model <- lmer(prob_score ~ complexity + actual*mixed + (1|brand), data = shuffling_data)
summary(mixed_model)
rm(mixed_model)
#stan model
stan_test <- stan_lmer(data = shuffling_data,
formula = prob_score ~ inv_complexity + actual*mixed + (1|brand),
prior = normal(0, 1), prior_intercept = normal(0, 1), prior_aux = exponential(3),
QR = TRUE, chains = 4, cores = 4, warmup = 1000, iter = 4000)
