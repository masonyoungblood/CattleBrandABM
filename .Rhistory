y = c(T = 2, S = 2, D = 1, G = 1, P = 1))
plot(dag)
#looks like we should include everything! there are not backdoor paths or
#anything else to consider because this is a controlled experiment... density
#will just be included as the number of trials for the binomial distribution
#load data
data("reedfrogs")
data <- reedfrogs
data$tank <- 1:nrow(data)
data$pred <- ifelse(data$pred == "no", 1, 2) #1 = no, 2 = yes
data$size <- ifelse(data$size == "small", 1, 2) #1 = small, 2 = big
data <- list(S = data$surv, D = data$density, T = data$tank, G = data$size, P = data$pred)
#run model
model <- ulam(alist(
S ~ dbinom(D, p),
logit(p) <- a[T] + b[P,G],
a[T] ~ dnorm(0, sigma),
matrix[P,G]:b ~ dnorm(0, 1),
sigma ~ dexp(1)
), data = data, chains = 4, cores = 4, log_lik = TRUE)
#print estimates
precis(model, pars = c("b", "sigma"), depth = 3)
#survival is highest for large tadpoles when predation is low, and only
#slightly lower for smaller tadpoles in the same condition... survival is lowest
#for the big tadpoles when predation is high, and is relatively lower for the
#smaller tadpoles in the same condition... interesting interaction!
# 3 -----------------------------------------------------------------------
#run model with density added as
model_dens <- ulam(alist(
S ~ dbinom(D, p),
logit(p) <- a[T] + b[P,G] + b_d[P]*D,
a[T] ~ dnorm(0, sigma),
matrix[P,G]:b ~ dnorm(0, 1),
b_d[P] ~ dnorm(0, 0.5),
sigma ~ dexp(1)
), data = data, chains = 4, cores = 4, log_lik = TRUE)
#print estimates
precis(model_dens, pars = c("b", "b_d", "sigma"), depth = 3)
#density appears to have a positive effect on survival when predation is low,
#and a negative effect on survival when predation is high
#compare sigmas from the two models
precis(model, pars = c("sigma"), depth = 3)
precis(model_dens, pars = c("sigma"), depth = 3)
#the sigma for the second model is lower than for the first model, which I think
#reflects the fact that the second model accounts for more of the variance in
#the data than the first because it includes density as a predictor
library(data.table)
library(parallel)
library(igraph)
library(scales)
install.packages("data.table")
install.packages("data.table")
#load packages
library(data.table)
library(parallel)
library(igraph)
library(scales)
#set population size
N <- 100
t_max <- 100
population <- data.table(trait = sample(c("A", "B"), N, replace = TRUE))
population
rep(NA, t_max)
#create output object
output <- rep(NA, t_max)
output
sum(population$trait == "A")/N
output[1] <- sum(population$trait == "A")/N
output
2:t_max
population$trait
factor(population$trait, levels = c("A", "B"))
table(factor(population$trait, levels = c("A", "B"))
)
table(factor(population$trait, levels = c("A", "B")))
as.numeric(table(factor(population$trait, levels = c("A", "B"))))
#calculate probabilities
probs <- lapply(1:N, function(x){as.numeric(table(factor(population$trait, levels = c("A", "B"))))})
probs
#calculate probabilities
probs <- lapply(1:N, function(x){as.numeric(table(factor(population$trait, levels = c("A", "B"))))})
prob[[1]]
probs[[1]]
sample(c("A", "B"), 1, prob = probs[[1]])
sample(c("A", "B"), 1, prob = probs[[1]])
sample(c("A", "B"), 1, prob = probs[[1]])
sample(c("A", "B"), 1, prob = probs[[1]])
sample(c("A", "B"), 1, prob = probs[[1]])
sample(c("A", "B"), 1, prob = probs[[1]])
sample(c("A", "B"), 1, prob = probs[[1]])
sample(c("A", "B"), 1, prob = probs[[1]])
sample(c("A", "B"), 1, prob = probs[[1]])
sample(c("A", "B"), 1, prob = probs[[1]])
sapply(1:N, function(x){sample(c("A", "B"), 1, prob = probs[[x]])})
population$trait
#copy from previous generation
set(population, j = "trait", value = sapply(1:N, function(x){sample(c("A", "B"), 1, prob = probs[[x]])}))
population$trait
N <- 100
t_max <- 100
#create population
population <- data.table(trait = sample(c("A", "B"), N, replace = TRUE))
#create output object
output <- rep(NA, t_max)
output[1] <- sum(population$trait == "A")/N
#agent based model loop
for(i in 2:t_max){
#calculate probabilities
probs <- lapply(1:N, function(x){as.numeric(table(factor(population$trait, levels = c("A", "B"))))})
#copy from previous generation
set(population, j = "trait", value = sapply(1:N, function(x){sample(c("A", "B"), 1, prob = probs[[x]])}))
#get p and put it into the output slot for this generation t
output[i] <- sum(population$trait == "A")/N
}
output
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 1), ylim = c(0, 1))
#load packages
library(data.table)
library(parallel)
library(igraph)
library(scales)
#cultural transmission function
transmission <- function(N = 100, p_0 = 0.5, t_max = 100){
#create population
population <- data.table(trait = sample(c("A", "B"), N, replace = TRUE, prob = c(p_0, 1 - p_0)))
#create output object
output <- rep(NA, t_max)
output[1] <- sum(population$trait == "A")/N
#agent based model loop
for(i in 2:t_max){
#calculate probabilities
probs <- lapply(1:N, function(x){as.numeric(table(factor(population$trait, levels = c("A", "B"))))})
#copy from previous generation
set(population, j = "trait", value = sapply(1:N, function(x){sample(c("A", "B"), 1, prob = probs[[x]])}))
#get p and put it into the output slot for this generation t
output[i] <- sum(population$trait == "A")/N
}
}
transmission()
output <- transmission()
output
#cultural transmission function
transmission <- function(N = 100, p_0 = 0.5, t_max = 100){
#create population
population <- data.table(trait = sample(c("A", "B"), N, replace = TRUE, prob = c(p_0, 1 - p_0)))
#create output object
output <- rep(NA, t_max)
output[1] <- sum(population$trait == "A")/N
#agent based model loop
for(i in 2:t_max){
#calculate probabilities
probs <- lapply(1:N, function(x){as.numeric(table(factor(population$trait, levels = c("A", "B"))))})
#copy from previous generation
set(population, j = "trait", value = sapply(1:N, function(x){sample(c("A", "B"), 1, prob = probs[[x]])}))
#get p and put it into the output slot for this generation t
output[i] <- sum(population$trait == "A")/N
}
#return output
return(output)
}
transmission()
transmission()
transmission()
iter <- 10
output <- mclapply(1:iter, function(x){transmission()}, mc.cores = 4)
output
output <- matrix(unlist(output), ncol = iter)
output
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 1), ylim = c(0, 1))
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 1000)}, mc.cores = 4)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
?alpha
as.numeric(table(factor(population$trait, levels = c("A", "B"))))
p_0 <- 0.5
#create population
population <- data.table(trait = sample(c("A", "B"), N, replace = TRUE, prob = c(p_0, 1 - p_0)))
N <- 100
#create population
population <- data.table(trait = sample(c("A", "B"), N, replace = TRUE, prob = c(p_0, 1 - p_0)))
as.numeric(table(factor(population$trait, levels = c("A", "B"))))
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 1000, p_0 = 0.1, content = 1.1)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
warnings()
#cultural transmission function
transmission <- function(N = 100, p_0 = 0.5, t_max = 100, content = 1){
#create population
population <- data.table(trait = sample(c("A", "B"), N, replace = TRUE, prob = c(p_0, 1 - p_0)))
#create output object
output <- rep(NA, t_max)
output[1] <- sum(population$trait == "A")/N
#agent based model loop
for(i in 2:t_max){
#calculate probabilities
probs <- lapply(1:N, function(x){as.numeric(table(factor(population$trait, levels = c("A", "B"))))*c(content, 1)})
#copy from previous generation
set(population, j = "trait", value = sapply(1:N, function(x){sample(c("A", "B"), 1, prob = probs[[x]])}))
#get p and put it into the output slot for this generation t
output[i] <- sum(population$trait == "A")/N
}
#return output
return(output)
}
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 1000, p_0 = 0.1, content = 1.1)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 1000, p_0 = 0.05, content = 1.05)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 100, p_0 = 0.05, content = 1.05)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
c(40, 60)
c(40, 60)^1.5
c(0.4, 0.6)^1.5
c(40, 60)
c(40, 60)^1.5
c(0.4, 0.6)^1.5
c(40, 60)^0.6
c(0.4, 0.6)^0.6
as.numeric(table(factor(population$trait, levels = c("A", "B"))))
as.numeric(table(factor(population$trait, levels = c("A", "B"))))^frequency
frequency <- 1
as.numeric(table(factor(population$trait, levels = c("A", "B"))))^frequency
(as.numeric(table(factor(population$trait, levels = c("A", "B"))))^frequency)*c(content, 1)
#cultural transmission function
transmission <- function(N = 100, p_0 = 0.5, t_max = 100, content = 1, frequency = 1){
#create population
population <- data.table(trait = sample(c("A", "B"), N, replace = TRUE, prob = c(p_0, 1 - p_0)))
#create output object
output <- rep(NA, t_max)
output[1] <- sum(population$trait == "A")/N
#agent based model loop
for(i in 2:t_max){
#calculate probabilities
probs <- lapply(1:N, function(x){(as.numeric(table(factor(population$trait, levels = c("A", "B"))))^frequency)*c(content, 1)})
#copy from previous generation
set(population, j = "trait", value = sapply(1:N, function(x){sample(c("A", "B"), 1, prob = probs[[x]])}))
#get p and put it into the output slot for this generation t
output[i] <- sum(population$trait == "A")/N
}
#return output
return(output)
}
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 1000, p_0 = 0.6, frequency = 1.1)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 1000, p_0 = 0.7, frequency = 0.9)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
transmission <- function(N = 100, p_0 = 0.5, t_max = 100, content = 1, frequency = 1){
#create population
population <- data.table(trait = sample(c("A", "B"), N, replace = TRUE, prob = c(p_0, 1 - p_0)))
#create output object
output <- rep(NA, t_max)
output[1] <- sum(population$trait == "A")/N
#agent based model loop
for(i in 2:t_max){
#calculate probabilities
probs <- lapply(1:N, function(x){(as.numeric(table(factor(population$trait, levels = c("A", "B"))))^frequency)*c(content, 1)})
#copy from previous generation
set(population, j = "trait", value = sapply(1:N, function(x){sample(c("A", "B"), 1, prob = probs[[x]])}))
#get p and put it into the output slot for this generation t
output[i] <- sum(population$trait == "A")/N
}
#return output
return(output)
}
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 1000, p_0 = 0.1, content = 1.1, frequency = 0.8)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
#create matrix of connection probability between clusters
pref_matrix <- matrix(0.01, nrow = 5, ncol = 5)
pref_matrix
diag(pref_matrix) <- 1
pref_matrix
#create and plot population structure
structure <- sample_sbm(100, pref_matrix, rep(100/5, 5))
par(mar = c(0, 0, 0, 0))
plot(structure, vertex.label = NA, vertex.size = 8)
N = 100
p_0 = 0.5
t_max = 100
content = 1
frequency = 1
cluster = 5
edge_prob = 0.01
#create and population structure
pref_matrix <- matrix(edge_prob, nrow = cluster, ncol = cluster)
diag(pref_matrix) <- 1
structure <- sample_sbm(N, pref_matrix, rep(N/cluster, cluster))
#create population
population <- data.table(trait = sample(c("A", "B"), N, replace = TRUE, prob = c(p_0, 1 - p_0)))
population
structure
structure[1]
structure[1] > 0
which(structure[1] > 0)
which(structure[2] > 0)
which(structure[10] > 0)
which(structure[100] > 0)
lapply(1:N, function(x){which(structure[x] > 0)})
#add connections to population table
population$connections <- lapply(1:N, function(x){which(structure[x] > 0)})
population
population$trait
population$connections[[1]]
population$trait[1]
population$trait[c(1, 2, 3)]
population$trait[population$connections[[1]]]
sample(c("A", "B"), N, replace = TRUE, prob = c(p_0, 1 - p_0))
sort(sample(c("A", "B"), N, replace = TRUE, prob = c(p_0, 1 - p_0)))
#cultural transmission function
transmission <- function(N = 100, p_0 = 0.5, t_max = 100, content = 1, frequency = 1, cluster = 5, edge_prob = 0.01){
#create and population structure
pref_matrix <- matrix(edge_prob, nrow = cluster, ncol = cluster)
diag(pref_matrix) <- 1
structure <- sample_sbm(N, pref_matrix, rep(N/cluster, cluster))
#create population
population <- data.table(trait = sort(sample(c("A", "B"), N, replace = TRUE, prob = c(p_0, 1 - p_0))))
#add connections to population table
population$connections <- lapply(1:N, function(x){which(structure[x] > 0)})
#create output object
output <- rep(NA, t_max)
output[1] <- sum(population$trait == "A")/N
#agent based model loop
for(i in 2:t_max){
#calculate probabilities
probs <- lapply(1:N, function(x){(as.numeric(table(factor(population$trait[population$connections[[x]]], levels = c("A", "B"))))^frequency)*c(content, 1)})
#copy from previous generation
set(population, j = "trait", value = sapply(1:N, function(x){sample(c("A", "B"), 1, prob = probs[[x]])}))
#get p and put it into the output slot for this generation t
output[i] <- sum(population$trait == "A")/N
}
#return output
return(output)
}
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 1000, p_0 = 0.6, content = 1, frequency = 1.1,
cluster = 5, edge_prob = 0.01)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 100, p_0 = 0.6, content = 1, frequency = 1.1,
cluster = 5, edge_prob = 0.01)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 500, p_0 = 0.6, content = 1, frequency = 1.1,
cluster = 5, edge_prob = 0.01)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 500, p_0 = 0.6, content = 1, frequency = 1.15,
cluster = 5, edge_prob = 0.01)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 500, p_0 = 0.6, content = 1, frequency = 1.15,
cluster = 5, edge_prob = 0.1)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 500, p_0 = 0.05, content = 1.2, frequency = 1,
cluster = 5, edge_prob = 0.01)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
iter <- 10
output <- mclapply(1:iter, function(x){transmission(N = 500, p_0 = 0.05, content = 1.2, frequency = 1,
cluster = 5, edge_prob = 0.1)}, mc.cores = 7)
output <- matrix(unlist(output), ncol = iter)
#plot
par(mar = c(4.5, 4.5, 0.5, 0.5))
matplot(output, type = "l", xlab = "Generation", ylab = "Proportion of individuals with A", lty = 1, col = alpha("black", 0.25), ylim = c(0, 1))
lines(rowMeans(output), col = "red", lwd = 2)
#load packages and data
setwd("~/Documents/Work/Summer_2021/Cattle_Brands/CattleBrandABM")
library(performance)
library(DHARMa)
library(lme4)
load("analysis/shuffling_model/shuffling_data.RData")
#data is zero inflated (8.5% of values)
length(which(shuffling_data$prob_score == 0))/nrow(shuffling_data)
#drop zeroes from the data
shuffling_data <- shuffling_data[-which(shuffling_data$prob_score == 0), ]
#convert variables to factors and binarize complexity
shuffling_data$time <- as.factor(shuffling_data$time)
shuffling_data$space <- as.factor(shuffling_data$space)
shuffling_data$brand <- as.factor(shuffling_data$brand)
shuffling_data$brand_num <- as.numeric(shuffling_data$brand)
shuffling_data$mixed <- ifelse(shuffling_data$mixed, 1, 0)
shuffling_data$complexity <- shuffling_data$complexity-2
#scale and log transform the probability score
shuffling_data$prob_score <- as.numeric(scale(log(shuffling_data$prob_score)))
#load output
load("analysis/shuffling_model/glmm_output.RData")
object.size(glmm_output$checks$mixed_model_confints)
object.size(glmm_output$checks$mixed_model_simres)
object.size(glmm_output$fixed_effects$complexity_model)
glmm_output <- list(random_effects = list(space_model = glmm_output$random_effects$space_model, time_model = glmm_output$random_effects$time_model, brand_model = glmm_output$random_effects$brand_model),
fixed_effects = list(complexity_model = glmm_output$fixed_effects$complexity_model, actual_model = glmm_output$fixed_effects$actual_model, mixed_model = glmm_output$fixed_effects$mixed_model),
estimates = list(mixed_model_confints = glmm_output$checks$mixed_model_confints))
save(glmm_output, file = "analysis/shuffling_model/glmm_output.RData")
#load packages and data
setwd("~/Documents/Work/Summer_2021/Cattle_Brands/CattleBrandABM")
library(performance)
library(DHARMa)
library(lme4)
load("analysis/shuffling_model/shuffling_data.RData")
#data is zero inflated (8.5% of values)
length(which(shuffling_data$prob_score == 0))/nrow(shuffling_data)
#drop zeroes from the data
shuffling_data <- shuffling_data[-which(shuffling_data$prob_score == 0), ]
#convert variables to factors and binarize complexity
shuffling_data$time <- as.factor(shuffling_data$time)
shuffling_data$space <- as.factor(shuffling_data$space)
shuffling_data$brand <- as.factor(shuffling_data$brand)
shuffling_data$brand_num <- as.numeric(shuffling_data$brand)
shuffling_data$mixed <- ifelse(shuffling_data$mixed, 1, 0)
shuffling_data$complexity <- shuffling_data$complexity-2
#scale and log transform the probability score
shuffling_data$prob_score <- as.numeric(scale(log(shuffling_data$prob_score)))
# #run all models
# space_model <- lmer(prob_score ~ (1|space), data = shuffling_data)
# time_model <- lmer(prob_score ~ (1|time), data = shuffling_data)
# brand_model <- lmer(prob_score ~ (1|brand), data = shuffling_data)
# complexity_model <- lmer(prob_score ~ complexity + (1|brand), data = shuffling_data)
# actual_model <- lmer(prob_score ~ actual + complexity + (1|brand), data = shuffling_data)
# mixed_model <- lmer(prob_score ~ complexity + actual*mixed + (1|brand), data = shuffling_data)
#
# #get estimates
# mixed_model_confints <- confint(mixed_model)
#
# #save output
# glmm_output <- list(random_effects = list(space_model = space_model, time_model = time_model, brand_model = brand_model),
#                     fixed_effects = list(complexity_model = complexity_model, actual_model = actual_model, mixed_model = mixed_model),
#                     estimates = list(mixed_model_confints = mixed_model_confints))
# save(glmm_output, file = "analysis/shuffling_model/glmm_output.RData")
#load output
load("analysis/shuffling_model/glmm_output.RData")
#get intra-class coefficients for each random effect
performance::icc(glmm_output$random_effects$space_model)
performance::icc(glmm_output$random_effects$time_model)
performance::icc(glmm_output$random_effects$brand_model)
#compare complexity model with random effects
compare_performance(glmm_output$random_effects$brand_model, glmm_output$fixed_effects$complexity_model, metrics = "AIC")
#compare complexity and actual model
compare_performance(glmm_output$fixed_effects$complexity_model, glmm_output$fixed_effects$actual_model, metrics = "AIC")
#compare actual and mixed model
compare_performance(glmm_output$fixed_effects$actual_model, glmm_output$fixed_effects$mixed_model, metrics = "AIC")
#get model estimates from mixed model
summary(glmm_output$fixed_effects$mixed_model)
glmm_output$checks$mixed_model_confints
glmm_output$estimates$mixed_model_confints
object.size(glmm_output$random_effects)
